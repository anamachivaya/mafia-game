<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Your Role - Mafia Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="manifest" href="/static/manifest.json">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Mafia Game">
  <link rel="apple-touch-icon" href="/static/mafia_bg_pic.jpg">
  <link rel="stylesheet" href="/static/snazzy.css">
  <style>
    body { 
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; 
      padding: 2rem; 
      background: #0f172a; 
      color: #e2e8f0; 
      min-height: 100vh;
      margin: 0;
    }
    .card { 
      max-width: 520px; 
      margin: 5vh auto; 
      background: #1e293b; 
      padding: 2rem; 
      border-radius: 12px; 
      box-shadow: 0 10px 30px rgba(0,0,0,0.3); 
      border: 1px solid #334155;
      position: relative;
    }
    .card.eliminated {
      border-color: #dc2626;
      background: #1a1a1a;
    }
    .status-indicator {
      position: absolute;
      top: 1rem;
      right: 1rem;
      padding: 0.5rem 1rem;
      border-radius: 6px;
      font-weight: bold;
      font-size: 0.9rem;
    }
    .status-alive {
      background: #059669;
      color: white;
    }
    .status-eliminated {
      background: #dc2626;
      color: white;
    }
    h1 { 
      margin-top: 0; 
      font-size: 1.6rem; 
      color: #f1f5f9;
      padding-right: 6rem;
    }
    h1.eliminated {
      color: #fca5a5;
      text-decoration: line-through;
    }
    .role-badge { 
      background: #fbbf24; 
      color: #92400e; 
      padding: 0.75rem 1.5rem; 
      border-radius: 8px; 
      font-weight: bold; 
      font-size: 1.2rem; 
      margin: 1rem 0; 
      text-align: center;
    }
    .role-badge.eliminated {
      background: #dc2626;
      color: white;
    }
    .warning { 
      background: #451a03; 
      color: #fbbf24; 
      padding: 1rem; 
      border-radius: 8px; 
      margin: 1rem 0; 
      border: 1px solid #92400e;
    }
    .description { 
      background: #374151; 
      padding: 1rem; 
      border-radius: 8px; 
      margin: 1rem 0; 
      color: #f1f5f9;
    }
    .description.eliminated {
      background: #4c1d1d;
      color: #fca5a5;
    }
    .button-group { 
      margin-top: 1.5rem; 
    }
    .btn { 
      padding: 0.8rem 1.5rem; 
      font-size: 1rem; 
      border: none; 
      border-radius: 8px; 
      cursor: pointer; 
      margin-right: 0.5rem; 
      margin-bottom: 0.5rem;
      font-weight: 600;
      transition: all 0.2s ease;
    }
    .btn-primary { 
      background: #2563eb; 
      color: white; 
    }
    .btn-primary:hover { 
      background: #1e40af; 
    }
    .btn-danger { 
      background: #dc2626; 
      color: white; 
    }
    .btn-danger:hover { 
      background: #b91c1c; 
    }
    .last-updated {
      font-size: 0.8rem;
      color: #94a3b8;
      margin-top: 1rem;
      text-align: center;
    }
    .footer { 
      text-align: center; 
      margin-top: 2rem; 
      color: #94a3b8; 
      font-size: 0.9rem; 
    }
    
    /* Elimination overlay */
    .elimination-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    .elimination-message {
      background: #1e293b;
      padding: 3rem;
      border-radius: 12px;
      text-align: center;
      border: 2px solid #dc2626;
      max-width: 400px;
    }
    .elimination-title {
      font-size: 4rem;
      margin-bottom: 1rem;
    }
    .elimination-text {
      font-size: 1.5rem;
      color: #fca5a5;
      margin-bottom: 1rem;
    }
    .elimination-status {
      background: #dc2626;
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 6px;
      font-weight: bold;
      display: inline-block;
    }
    
    /* Eliminated styling */
    .eliminated {
      opacity: 0.7;
    }
    /* Faction badge styles */
    .faction-badge {
      display: inline-block;
      padding: 0.25rem 0.6rem;
      border-radius: 8px;
      font-size: 0.9rem;
      font-weight: 700;
      color: white;
      margin-left: 0.6rem;
      border: 1px solid rgba(255,255,255,0.03);
    }
    .faction-mafia { background: #b91c1c; }
    .faction-villagers { background: #059669; }
    .faction-neutral { background: #6b7280; }
    .faction-unknown { background: #374151; color: #f1f5f9; }
    /* Unified faction color on player screen */
    .faction-unified { background: #2563eb; }
  </style>
</head>
<body>
  <div class="card" id="gameCard">
    <div class="status-indicator status-alive" id="statusIndicator">ALIVE</div>
    
    <h1 id="playerName">Welcome, {{ name | e }}!</h1>
    
    <div style="display:flex; align-items:center; gap:0.75rem;">
      <div class="role-badge" id="roleBadge">{{ role | e }}</div>
      {% if faction %}
        {# Show a unified faction badge color on the player role screen for consistency #}
        <span class="faction-badge faction-unified">{{ faction | e }}</span>
      {% endif %}
    </div>
    
    <div class="warning" id="warningMessage">
      ü§´ Keep your role secret! Don't let other players see this screen.
    </div>
    
    <div class="description" id="roleDescription">
      {{ description | e }}
    </div>

    <!-- Night action UI -->
    <div id="actionSection" class="mt-1" style="display:none;">
      <div class="roles-header">Current Phase: <span id="currentPhase">‚Äî</span> <small id="currentStep" class="small muted-small"></small></div>
      <div id="actionControls" class="panel role-card" style="padding:.75rem;">
        <div id="actionMessage" class="small">No actions available right now.</div>
        <div id="actionTargets" style="margin-top:.75rem; display:flex; flex-direction:column; gap:0.4rem;"></div>
      </div>
    </div>

    <!-- Visible teammates (e.g., mafias see other mafias) -->
    <div id="visibleTeammatesSection" style="display:none; margin-top:1rem;">
      <div class="roles-header">üïµÔ∏è‚Äç‚ôÇÔ∏è Teammates you can see</div>
      <div id="visibleTeammatesList" style="display:flex; flex-direction:column; gap:0.5rem;"></div>
    </div>
    
    <div class="button-group">
  <!-- Removed manual refresh: players view role automatically via the main page -->
      
      <form method="post" action="{{ url_for('leave') }}" style="display: inline;">
        <input type="hidden" name="player_name" value="{{ name }}">
        <button type="submit" class="btn btn-danger" onclick="return confirm('Are you sure you want to leave the game?')">Leave Game</button>
      </form>
    </div>
    
    <div class="last-updated" id="lastUpdated">Last checked: ‚Äî</div>
  </div>

  <div id="playerNightResults" class="wrap" style="max-width:520px; margin-top:1rem; display:none;">
    <div class="results-panel" id="playerLastNightResults">No results yet.</div>
  </div>

  <!-- Paused overlay for non-actors -->
  <div class="paused-overlay" id="pausedOverlay">
    <div class="paused-message">
      <h2 id="pausedTitle">Waiting...</h2>
      <p id="pausedText">Waiting for other players to act. This screen will become active when it's your turn.</p>
    </div>
  </div>

  <!-- Elimination overlay -->
  <div class="elimination-overlay" id="eliminationOverlay">
    <div class="elimination-message">
      <div class="elimination-title">üíÄ</div>
      <div class="elimination-text">You have been eliminated!</div>
      <div class="elimination-status">ELIMINATED</div>
      <p style="color: #94a3b8; margin-top: 2rem;">
        You can continue to watch the game, but you can no longer participate.
      </p>
      <button class="btn btn-primary" onclick="window.location.href='/watch/' + encodeURIComponent(ROOM_NAME)" style="margin-top: 1rem;">
        Continue Watching
      </button>
    </div>
  </div>

  <!-- Toast notification for brief messages before redirects -->
  <div id="toast" style="display:none; position: fixed; left: 50%; transform: translateX(-50%); bottom: 12vh; background: rgba(0,0,0,0.7); color: #fff; padding: 0.8rem 1.2rem; border-radius: 8px; font-weight: 700; box-shadow: 0 6px 20px rgba(0,0,0,0.5); z-index: 1100;">
    <span id="toastMessage">Message</span>
  </div>

  <div class="footer">
    Created by Scissors. Powered by Sunisha and Diet Coke
  </div>

  <script>
    const PLAYER_NAME = '{{ name | e }}';
    const ROOM_NAME = '{{ room_name | e }}';
    
    let isEliminated = false;
    let hasShownEliminationMessage = false;

    function escapeHtml(str) {
      const p = document.createElement('p');
      p.innerText = str;
      return p.innerHTML;
    }

    function showToast(msg, ms = 1200) {
      try {
        const toast = document.getElementById('toast');
        const msgEl = document.getElementById('toastMessage');
        msgEl.textContent = msg;
        toast.style.display = 'block';
        // fade in
        toast.style.opacity = 0;
        toast.style.transition = 'opacity 160ms ease';
        requestAnimationFrame(() => { toast.style.opacity = 1; });
        setTimeout(() => {
          // fade out
          toast.style.opacity = 0;
          setTimeout(() => { toast.style.display = 'none'; }, 220);
        }, ms);
      } catch (e) { console.warn('Toast failed', e); }
    }

    function showEliminationOverlay() {
      if (!hasShownEliminationMessage) {
        document.getElementById('eliminationOverlay').style.display = 'flex';
        hasShownEliminationMessage = true;
      }
    }

    function hideEliminationOverlay() {
      document.getElementById('eliminationOverlay').style.display = 'none';
    }

    function updateEliminationStatus(eliminated) {
      const gameCard = document.getElementById('gameCard');
      const playerName = document.getElementById('playerName');
      const roleBadge = document.getElementById('roleBadge');
      const roleDescription = document.getElementById('roleDescription');
      const statusIndicator = document.getElementById('statusIndicator');
      const warningMessage = document.getElementById('warningMessage');

      if (eliminated && !isEliminated) {
        // Player just got eliminated
        isEliminated = true;
        
        // Update visual elements
        gameCard.classList.add('eliminated');
        playerName.classList.add('eliminated');
        roleBadge.classList.add('eliminated');
        roleDescription.classList.add('eliminated');
        
        statusIndicator.textContent = 'ELIMINATED üíÄ';
        statusIndicator.className = 'status-indicator status-eliminated';
        
        warningMessage.innerHTML = 'üíÄ You have been eliminated from the game!';
        warningMessage.style.background = '#4c1d1d';
        warningMessage.style.color = '#f87171';
        warningMessage.style.borderColor = '#dc2626';
        
        // Show elimination overlay
        showEliminationOverlay();
        
      } else if (!eliminated && isEliminated) {
        // Player was revived (unlikely but possible)
        isEliminated = false;
        
        // Remove elimination styling
        gameCard.classList.remove('eliminated');
        playerName.classList.remove('eliminated');
        roleBadge.classList.remove('eliminated');
        roleDescription.classList.remove('eliminated');
        
        statusIndicator.textContent = 'ALIVE';
        statusIndicator.className = 'status-indicator status-alive';
        
        warningMessage.innerHTML = "ü§´ Keep your role secret! Don't let other players see this screen.";
        warningMessage.style.background = '#451a03';
        warningMessage.style.color = '#fbbf24';
        warningMessage.style.borderColor = '#92400e';
        
        hideEliminationOverlay();
      }
    }

    async function checkEliminationStatus() {
      try {
        const response = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/players`, {
          cache: 'no-store'
        });
        
        if (!response.ok) {
          throw new Error('Failed to fetch player status');
        }
        
        const data = await response.json();
  const eliminatedPlayers = data.eliminated_players || [];
        const isPlayerEliminated = eliminatedPlayers.includes(PLAYER_NAME);
        
        updateEliminationStatus(isPlayerEliminated);

        // If the host has restarted the game, assignments may be cleared and game_started will be false.
        // In that case, redirect this player back to the waiting/thanks page so they see the lobby.
        const gameStarted = !!data.game_started;
        const assignments = data.assignments || {};
        const hasAssignment = Object.prototype.hasOwnProperty.call(assignments, PLAYER_NAME);
        if (!gameStarted || !hasAssignment) {
          // Show a brief toast so player understands what's happening, then redirect back to the lobby/waiting page
          showToast('Host restarted the game ‚Äî returning to lobby...', 1400);
          setTimeout(() => {
            window.location.replace(`/room/${encodeURIComponent(ROOM_NAME)}`);
          }, 1400);
          return;
        }
        
        // Update last checked time
        const now = new Date();
        document.getElementById('lastUpdated').textContent = 
          'Last checked: ' + now.toLocaleTimeString();

        // Show limited last night results to players (names only)
        try {
          const results = data.last_night_results || {};
          const pPanel = document.getElementById('playerNightResults');
          const pContainer = document.getElementById('playerLastNightResults');
          if (results && (results.killed && results.killed.length || results.muted)) {
            let html = '';
            if (results.killed && results.killed.length) {
              html += `<div class="killed">Killed: ${results.killed.map(x => escapeHtml(x)).join(', ')}</div>`;
            }
            if (results.muted) {
              html += `<div class="muted">Muted: ${escapeHtml(results.muted)}</div>`;
            }
            pContainer.innerHTML = html;
            pPanel.style.display = 'block';
          } else {
            pPanel.style.display = 'none';
          }
        } catch (e) { console.warn('Could not render player night results', e); }

        // Render visible teammates if provided (e.g., mafia members)
        try {
          const visible = data.visible_roles || [];
          const section = document.getElementById('visibleTeammatesSection');
          const list = document.getElementById('visibleTeammatesList');
          if (visible && visible.length) {
            section.style.display = 'block';
            list.innerHTML = '';
            visible.forEach(v => {
              const el = document.createElement('div');
              el.className = 'visible-teammate';
              el.innerHTML = `<strong>${escapeHtml(v.name)}</strong><span class="faction-badge faction-unified">${escapeHtml(v.role)}</span>`;
              list.appendChild(el);
            });
          } else {
            section.style.display = 'none';
            list.innerHTML = '';
          }
        } catch (e) { console.warn('Could not render visible teammates', e); }
        
      } catch (error) {
        console.error('Error checking elimination status:', error);
        document.getElementById('lastUpdated').textContent = 
          'Last checked: Error connecting to server';
      }
    }

    // Check elimination status immediately and then every 3 seconds
    checkEliminationStatus();
    setInterval(checkEliminationStatus, 3000);
    
    // Phase polling and action handling (with caching and step-change rendering)
    let _lastStep = null;
    let _cachedPlayers = null;
    const _mySelections = {}; // action -> target

    async function fetchPhase() {
      try {
        const res = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/phase`, { cache: 'no-store' });
        if (!res.ok) return;
        const data = await res.json();
        const phase = data.phase || 'lobby';
        const step = data.phase_step || '';
        document.getElementById('currentPhase').textContent = phase.toUpperCase();
        document.getElementById('currentStep').textContent = step ? `‚Äî ${step}` : '';

        const actionSection = document.getElementById('actionSection');
        const actionControls = document.getElementById('actionControls');
        const actionMessage = document.getElementById('actionMessage');
        const actionTargets = document.getElementById('actionTargets');

        if (phase === 'night') {
          actionSection.style.display = 'block';
          const role = document.getElementById('roleBadge').textContent.trim().toLowerCase();
          const expected = data.expected_actors || [];
          const amExpected = expected.includes(PLAYER_NAME);
          const pausedOverlay = document.getElementById('pausedOverlay');
          const pausedTitle = document.getElementById('pausedTitle');
          const pausedText = document.getElementById('pausedText');
          if (!amExpected) {
            // show a full-screen paused overlay so players know they cannot act
            pausedOverlay.style.display = 'flex';
            pausedTitle.textContent = `Waiting for ${expected.length ? expected.join(', ') : 'others'}`;
            pausedText.textContent = 'This screen will be active when it is your role\'s turn to perform an action.';
            actionTargets.innerHTML = '';
            actionMessage.textContent = `Waiting for ${expected.length ? expected.join(', ') : 'others'} to act...`;
            return;
          } else {
            // hide overlay and allow interaction
            pausedOverlay.style.display = 'none';
          }

          // fetch players once per night (cache until phase changes)
          if (!_cachedPlayers) {
            const pResp = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/players`, { cache: 'no-store' });
            const pData = await pResp.json();
            _cachedPlayers = pData.players || [];
          }
          const playerOptions = _cachedPlayers.filter(p => p !== PLAYER_NAME);

          // Only re-render controls when step changes to avoid flicker
          if (_lastStep !== step) {
            _lastStep = step;
            actionTargets.innerHTML = '';
            actionMessage.textContent = 'Select a target below and submit your action.';

            function makeTargetButton(target, actionName) {
              const btn = document.createElement('button');
              btn.className = 'player-pill';
              btn.textContent = target;
              btn.dataset.target = target;
              // restore selection if any
              if (_mySelections[actionName] && _mySelections[actionName] === target) btn.classList.add('selected');
              btn.onclick = () => {
                // mark selected only within this action group
                const siblings = actionTargets.querySelectorAll(`.player-pill[data-action='${actionName}']`);
                siblings.forEach(s => s.classList.remove('selected'));
                btn.classList.add('selected');
                _mySelections[actionName] = target;
              };
              // tag which action group this button belongs to (host will create separate groups)
              btn.setAttribute('data-action', actionName);
              return btn;
            }

            // helper to append action UI
            function appendActionUI(labelText, actionName, options, submitLabel, submitAction, primary=false) {
              const label = document.createElement('div'); label.textContent = labelText;
              actionTargets.appendChild(label);
              options.forEach(p => actionTargets.appendChild(makeTargetButton(p, actionName)));
              const submit = document.createElement('button');
              submit.className = primary ? 'btn btn-danger mt-1' : 'btn btn-primary mt-1';
              submit.textContent = submitLabel;
              submit.onclick = async () => {
                const sel = actionTargets.querySelector(`.player-pill[data-action='${actionName}'].selected`);
                const target = sel ? sel.dataset.target : '';
                if (!target && submitAction !== 'bodyguard_save') { showToast('Choose a player first'); return; }
                await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/submit-action`, { method: 'POST', body: new URLSearchParams({ action: submitAction, target }) });
                _mySelections[actionName] = target;
                showToast(submitLabel + ' recorded');
              };
              actionTargets.appendChild(submit);
            }

            // Which actions to show (role substring based)
            if (role.includes('mafia')) {
              appendActionUI('Mafia: propose a kill (consensus)', 'mafia_proposal', playerOptions, 'Propose Kill', 'mafia_proposal');
            }
            if (role.includes('godfather')) {
              appendActionUI('Godfather: finalize mafia kill', 'mafia_kill', playerOptions, 'Finalize Kill (Godfather)', 'mafia_kill', true);
            }
            if (role.includes('framer')) {
              appendActionUI('Framer: choose a player to frame', 'frame', playerOptions, 'Frame Player', 'frame');
            }
            if (role.includes('doctor') || role.includes('medic')) {
              appendActionUI('Doctor: choose a player to save', 'save', [PLAYER_NAME].concat(playerOptions), 'Save Player', 'save');
            }
            if (role.includes('cop') || role.includes('sheriff') || role.includes('detective')) {
              appendActionUI('Cop: choose a player to check', 'check', playerOptions, 'Check Player', 'check');
            }
            if (role.includes('vigilante')) {
              appendActionUI('Vigilante: choose a player to kill', 'vigilante_kill', [PLAYER_NAME].concat(playerOptions), 'Kill Player', 'vigilante_kill', true);
            }
            if (role.includes('bodyguard')) {
              appendActionUI('Bodyguard: choose a player to protect (or pick none)', 'bodyguard_save', [PLAYER_NAME].concat(playerOptions), 'Protect Player', 'bodyguard_save');
            }
            if (role.includes('sheriff') || role.includes('muter')) {
              appendActionUI('Sheriff: choose a player to mute this round', 'mute', playerOptions, 'Mute Player', 'mute');
            }
          } else {
            // step didn't change: keep cached players and selections; ensure action section visible
            actionSection.style.display = 'block';
            // re-highlight any selections preserved in _mySelections
            for (const [actionName, tgt] of Object.entries(_mySelections)) {
              const btn = actionTargets.querySelector(`.player-pill[data-action='${actionName}'][data-target='${tgt}']`);
              if (btn) btn.classList.add('selected');
            }
          }

        } else {
          // not night
          document.getElementById('actionSection').style.display = 'none';
          _lastStep = null;
          _cachedPlayers = null;
          // clear selections when day starts
          // (keep history in UI via last_night_results)
        }
      } catch (e) { console.warn('phase poll failed', e); }
    }

  // Start polling phase every 1.5 seconds (render only on step changes)
    fetchPhase();
    setInterval(fetchPhase, 1500);
  </script>
</body>
<script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', function() {
      navigator.serviceWorker.register('/static/sw.js').catch(function(err){ console.warn('SW registration failed:', err); });
    });
  }
</script>
</html>