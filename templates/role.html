<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Your Role - Mafia Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="manifest" href="/static/manifest.json">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Mafia Game">
  <link rel="apple-touch-icon" href="/static/mafia_bg_pic.jpg">
  <script>
    try {
      if ('ontouchstart' in window || (navigator.maxTouchPoints && navigator.maxTouchPoints > 0)) {
        document.documentElement.classList.add('has-touch');
      }
    } catch (e) {}
  </script>
  <style>
    body { 
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; 
      padding: 2rem; 
      background: #0f172a; 
      color: #e2e8f0; 
      min-height: 100vh;
      margin: 0;
    }
    .card { 
      max-width: 520px; 
      margin: 5vh auto; 
      background: #1e293b; 
      padding: 2rem; 
      border-radius: 12px; 
      box-shadow: 0 10px 30px rgba(0,0,0,0.3); 
      border: 1px solid #334155;
      position: relative;
    }
    .card.eliminated {
      border-color: #dc2626;
      background: #1a1a1a;
    }
    .status-indicator {
      position: absolute;
      top: 1rem;
      right: 1rem;
      padding: 0.5rem 1rem;
      border-radius: 6px;
      font-weight: bold;
      font-size: 0.9rem;
    }
    .status-alive {
      background: #059669;
      color: white;
    }
    .status-eliminated {
      background: #dc2626;
      color: white;
    }
    h1 { 
      margin-top: 0; 
      font-size: 1.6rem; 
      color: #f1f5f9;
      padding-right: 6rem;
    }
    h1.eliminated {
      color: #fca5a5;
      text-decoration: line-through;
    }
    .role-badge { 
      background: #fbbf24; 
      color: #92400e; 
      padding: 0.75rem 1.5rem; 
      border-radius: 8px; 
      font-weight: bold; 
      font-size: 1.2rem; 
      margin: 1rem 0; 
      text-align: center;
    }
    .role-badge.eliminated {
      background: #dc2626;
      color: white;
    }
    .warning { 
      background: #451a03; 
      color: #fbbf24; 
      padding: 1rem; 
      border-radius: 8px; 
      margin: 1rem 0; 
      border: 1px solid #92400e;
    }
    .description { 
      background: #374151; 
      padding: 1rem; 
      border-radius: 8px; 
      margin: 1rem 0; 
      color: #f1f5f9;
    }
    .description.eliminated {
      background: #4c1d1d;
      color: #fca5a5;
    }
    .button-group { 
      margin-top: 1.5rem; 
    }
    .btn { 
      padding: 0.8rem 1.5rem; 
      font-size: 1rem; 
      border: none; 
      border-radius: 8px; 
      cursor: pointer; 
      margin-right: 0.5rem; 
      margin-bottom: 0.5rem;
      font-weight: 600;
      transition: all 0.2s ease;
    }
    .btn-primary { 
      background: #2563eb; 
      color: white; 
    }
    html:not(.has-touch) .btn-primary:hover { 
      background: #1e40af; 
    }
    .btn-danger { 
      background: #dc2626; 
      color: white; 
    }
    html:not(.has-touch) .btn-danger:hover { 
      background: #b91c1c; 
    }
    .last-updated {
      font-size: 0.8rem;
      color: #94a3b8;
      margin-top: 1rem;
      text-align: center;
    }
    .footer { 
      text-align: center; 
      margin-top: 2rem; 
      color: #94a3b8; 
      font-size: 0.9rem; 
    }
    
    /* Elimination overlay */
    .elimination-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    .elimination-message {
      background: #1e293b;
      padding: 3rem;
      border-radius: 12px;
      text-align: center;
      border: 2px solid #dc2626;
      max-width: 400px;
    }
    .elimination-title {
      font-size: 4rem;
      margin-bottom: 1rem;
    }
    .elimination-text {
      font-size: 1.5rem;
      color: #fca5a5;
      margin-bottom: 1rem;
    }
    .elimination-status {
      background: #dc2626;
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 6px;
      font-weight: bold;
      display: inline-block;
    }
    
    /* Eliminated styling */
    .eliminated {
      opacity: 0.7;
    }
    /* Faction badge styles */
    .faction-badge {
      display: inline-block;
      padding: 0.25rem 0.6rem;
      border-radius: 8px;
      font-size: 0.9rem;
      font-weight: 700;
      color: white;
      margin-left: 0.6rem;
      border: 1px solid rgba(255,255,255,0.03);
    }
    .faction-mafia { background: #b91c1c; }
    .faction-villagers { background: #059669; }
    .faction-neutral { background: #6b7280; }
    .faction-unknown { background: #374151; color: #f1f5f9; }
    /* Unified faction color on player screen */
    .faction-unified { background: #2563eb; }
    /* Night target tile styles */
    .target-tile {
      background: #071020;
      border: 1px solid rgba(255,255,255,0.04);
      border-radius: 8px;
      padding: 0.6rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      align-items: stretch;
      transition: transform 120ms ease, box-shadow 120ms ease, opacity 160ms ease;
    }
    .target-tile.clickable { cursor: pointer; }
  html:not(.has-touch) .target-tile.clickable:hover { transform: translateY(-4px); box-shadow: 0 8px 26px rgba(2,6,23,0.6); }
    .target-tile.disabled { opacity: 0.55; cursor: not-allowed; }
    .target-tile .player-name { font-weight:700; }
    .target-tile .tile-actions { display:flex; gap:0.5rem; }
    .target-tile .checkmark {
      position: relative;
    }
    .tile-checkmark-badge {
      position: absolute;
      right: 6px;
      top: 6px;
      background: #10b981;
      color: white;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      box-shadow: 0 4px 14px rgba(16,185,129,0.16);
    }
    /* Suicide modal choice styles */
    .suicide-choice {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      padding: 0.6rem 0.75rem;
      background: #071022;
      border: 1px solid rgba(255,255,255,0.04);
      border-radius: 10px;
      cursor: pointer;
      transition: transform 120ms ease, box-shadow 120ms ease, background 120ms ease, border-color 120ms ease;
      color: #e2e8f0;
      font-weight: 700;
    }
  html:not(.has-touch) .suicide-choice:hover { transform: translateY(-3px); box-shadow: 0 8px 24px rgba(2,6,23,0.6); }
    .suicide-choice.disabled { opacity: 0.5; cursor: not-allowed; transform: none; box-shadow: none; }
    .suicide-choice .name { flex: 1; text-align: left; }
    .suicide-choice .check { width: 28px; height: 28px; border-radius: 50%; display: inline-flex; align-items: center; justify-content: center; font-size: 14px; }
    .suicide-choice .check.hidden { visibility: hidden; }
    .suicide-choice.selected { background: linear-gradient(90deg,#7c3aed,#2563eb); border-color: rgba(124,58,237,0.6); color: white; }
    .suicide-choice.selected .check { background: rgba(255,255,255,0.12); color: #fff; box-shadow: 0 6px 18px rgba(37,99,235,0.18); }
  </style>
  <style>
    /* Mobile-fullscreen modal adjustments: make modals full screen on touch devices for safer private actions */
    .modal-inner { max-width: 640px; margin: 0 auto; }
    html.has-touch #nightModal > div,
    html.has-touch #suicideModal > div,
    html.has-touch #votingModal > div,
    html.has-touch #actionConfirmModal > div {
      width: 100% !important;
      height: 100% !important;
      max-width: none !important;
      border-radius: 0 !important;
      padding: 1rem !important;
      box-sizing: border-box;
      display: flex !important;
      flex-direction: column !important;
      justify-content: flex-start !important;
    }
    html.has-touch #nightModal { align-items: flex-start; padding-top: 10vh; }
    html.has-touch #votingModal { align-items: flex-start; padding-top: 10vh; }

    /* Voting banner */
    #votingBanner { display:none; position:fixed; left:50%; transform:translateX(-50%) translateY(-8px); top:12px; z-index:1400; padding:0.8rem 1rem; border-radius:8px; font-weight:900; color:#fff; background:linear-gradient(90deg,#2563eb,#7c3aed); box-shadow:0 10px 30px rgba(2,6,23,0.6); opacity:0; transition: transform 260ms cubic-bezier(.2,.9,.2,1), opacity 260ms ease; }
    #votingBanner.show { display:block; transform:translateX(-50%) translateY(0); opacity:1; }

    /* Role reveal overlay (used for kill/lynch reveals). Mobile friendly, full-screen readable card */
    .reveal-overlay { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(2,6,23,0.86); z-index:1600; }
    .reveal-card { background: #0b1220; color: #fff; border-radius: 12px; padding: 1.25rem; max-width: 420px; width: min(92%,420px); text-align: center; border: 1px solid rgba(255,255,255,0.04); box-shadow: 0 12px 36px rgba(2,6,23,0.7); }
    .reveal-name { font-size: 1.6rem; font-weight:900; margin-bottom: 0.25rem; }
    .reveal-role { font-size: 1.2rem; font-weight:700; color: #fbbf24; margin-bottom: 0.5rem; }
    .reveal-cause { font-size: 0.95rem; color: #f87171; margin-bottom: 0.85rem; }
    @keyframes revealPop { 0% { transform: scale(0.88); opacity:0 } 60% { transform: scale(1.04); opacity:1 } 100% { transform: scale(1); opacity:1 } }
    .reveal-card.pop { animation: revealPop 420ms cubic-bezier(.2,.9,.2,1); }

    /* Eliminated log inside the overlay */
    #eliminationLog { max-height: 40vh; overflow:auto; margin-top: 0.75rem; background:#071024; border-radius:8px; padding:0.6rem; border:1px solid rgba(255,255,255,0.03); text-align:left; font-size:0.95rem; }
    #eliminationLog .log-entry { padding:0.35rem 0; border-bottom:1px dashed rgba(255,255,255,0.02); }
    #eliminationLog .log-entry time { color:#94a3b8; font-size:0.82rem; margin-right:0.5rem; }
    .log-controls { display:flex; gap:0.5rem; justify-content:center; margin-top:0.6rem; }
  </style>
</head>
<body>
  <div class="card" id="gameCard">
    <div class="status-indicator status-alive" id="statusIndicator">ALIVE</div>
    
    <h1 id="playerName">Welcome, {{ name | e }}!</h1>
    
    <div style="display:flex; align-items:center; gap:0.75rem;">
      <div class="role-badge" id="roleBadge">{{ role | e }}</div>
      {% if faction %}
        {# Show a unified faction badge color on the player role screen for consistency #}
        <span class="faction-badge faction-unified">{{ faction | e }}</span>
      {% endif %}
    </div>
    
    <div class="warning" id="warningMessage">
      🤫 Keep your role secret! Don't let other players see this screen.
    </div>
    
    <div class="description" id="roleDescription">
      {{ description | e }}
    </div>

    <!-- Mafia coordination removed: mafia_final is handled by a single chooser (godfather/framer/random mafia)
         UI will prompt the designated chooser to submit mafia_final when appropriate. -->

    <!-- Visible teammates (e.g., mafias see other mafias) -->
    <div id="visibleTeammatesSection" style="display:none; margin-top:1rem;">
      <div class="roles-header">🕵️‍♂️ Teammates you can see</div>
      <div id="visibleTeammatesList" style="display:flex; flex-direction:column; gap:0.5rem;"></div>
    </div>
    
    <div class="button-group">
  <!-- Show/Hide role toggle -->
      <button id="toggleRoleBtn" class="btn btn-primary" onclick="toggleRoleVisibility(); return false;">Hide Role</button>
      
      <form method="post" action="{{ url_for('leave') }}" style="display: inline;">
        <input type="hidden" name="player_name" value="{{ name }}">
        <button type="submit" class="btn btn-danger" onclick="return confirm('Are you sure you want to leave the game?')">Leave Game</button>
      </form>
    </div>
    
    <div class="last-updated" id="lastUpdated">Last checked: —</div>
  </div>

  <!-- Winner banner for players -->
  <div id="winnerBannerPlayer" style="display:none; position:fixed; left:50%; transform:translateX(-50%); top:12px; z-index:1300; padding:0.8rem 1rem; border-radius:8px; font-weight:900; color:#fff; background:#111; box-shadow:0 8px 24px rgba(0,0,0,0.6);">
    <span id="winnerBannerText">Winner: —</span>
  </div>

  <!-- Voting banner (animated) -->
  <div id="votingBanner">Voting Started — Participate Now</div>

  <!-- Speech notify toggle (client-only) -->
  <!-- (speech announce removed - speech is automatic when it's your turn) -->

  <!-- Global mute toggle (client-only) -->
  <div style="position:fixed;right:14px;bottom:64px;z-index:9999">
    <button id="siteMuteBtn" aria-pressed="false" aria-label="Mute site" title="Mute site"
      style="background:#fff;padding:8px;border-radius:999px;box-shadow:0 2px 6px rgba(0,0,0,.15);border:none;display:inline-flex;align-items:center;justify-content:center;">
      <svg id="siteMuteIcon" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#0f172a" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
        <path d="M11 5L6 9H3v6h3l5 4V5z" />
        <path id="siteMuteWave" d="M19 9a4 4 0 0 1 0 6" />
      </svg>
    </button>
  </div>

  <!-- Role reveal overlay (for kills/lynches) -->
  <div class="reveal-overlay" id="revealOverlay" aria-hidden="true">
    <div class="reveal-card" role="dialog" aria-modal="true">
      <div class="reveal-name" id="revealName">Player</div>
      <div class="reveal-role" id="revealRole">Role</div>
      <div class="reveal-cause" id="revealCause">Cause</div>
      <div id="eliminationLog"></div>
      <div class="log-controls">
        <button class="btn" onclick="hideRevealOverlay()">Close</button>
        <button class="btn btn-primary" onclick="copyEliminationLog()">Copy Log</button>
      </div>
    </div>
  </div>

  <!-- Read-only Moderator Dashboard for players (no action buttons) -->
  <div class="card" style="max-width:900px; margin: 1.25rem auto;" id="playerModeratorDashboard">
    <h3 style="margin-top:0;">Game Status</h3>
    <div style="display:flex; gap:1rem; flex-wrap:wrap;">
      <div style="flex:1; min-width:160px;">
        <div class="small">Phase</div>
        <div style="font-weight:800; font-size:1.05rem;" id="pdPhase">—</div>
        <div class="small" style="margin-top:0.5rem;">Night step</div>
        <div style="font-weight:700;" id="pdNightStep">—</div>
      </div>
      <div style="flex:1; min-width:160px;">
        <div class="small">Last night killed</div>
        <div style="font-weight:700;" id="pdLastKilled">—</div>
        <div class="small" style="margin-top:0.5rem;">Last night muted</div>
        <div style="font-weight:700;" id="pdLastMuted">—</div>
      </div>
      <div style="flex:1; min-width:220px; display:flex; flex-direction:column; gap:0.5rem;">
        <div>
          <div class="small">Last night events</div>
          <div id="pdLastEvents" style="background:#071024; padding:0.5rem; border-radius:8px; border:1px solid rgba(255,255,255,0.03); max-height:80px; overflow:auto;">—</div>
        </div>
        <div>
          <div class="small">Voting</div>
          <!-- Player voting dashboard: visual parity with host voting dashboard (read-only) -->
          <div id="votingDashboard" style="background:#071024; padding:0.5rem; border-radius:8px; border:1px solid rgba(255,255,255,0.03); max-height:160px; overflow:auto; display:none;">
            <div style="display:flex; gap:1rem; flex-wrap:wrap; align-items:flex-start;">
              <div style="flex:1; min-width:140px;">
                <div class="small">Voting status</div>
                <div id="votingStatus" style="font-weight:800; font-size:1rem;">—</div>
                <div class="small" style="margin-top:0.5rem;">Current voter</div>
                <div id="votingCurrent" style="font-weight:700; font-size:1.05rem;">—</div>
              </div>

              <div style="flex:1.2; min-width:160px;">
                <div class="small">Vote tally (players with >=1 vote)</div>
                <div id="votingTally" style="background:#071024; padding:0.75rem; border-radius:8px; border:1px solid rgba(255,255,255,0.03); max-height:120px; overflow:auto;">—</div>
              </div>

              <div style="flex:1.4; min-width:180px;">
                <div class="small">Vote log (running)</div>
                <div id="votingLog" style="background:#071024; padding:0.75rem; border-radius:8px; border:1px solid rgba(255,255,255,0.03); max-height:120px; overflow:auto;">—</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div style="position:fixed; left:1rem; bottom:1rem; color:#94a3b8; font-size:0.9rem;" id="nightStepIndicator"> </div>

  <!-- Night action modal: replaced select with clickable player tiles -->
  <div id="nightModal" style="display:none; position:fixed; left:0; top:0; width:100%; height:100%; background:rgba(0,0,0,0.6); align-items:center; justify-content:center; z-index:1200;">
    <div style="background:#0b1220; padding:1rem 1.25rem; border-radius:10px; width:640px; max-width:95%; border:1px solid rgba(255,255,255,0.04);">
      <h3 id="nightModalTitle" style="margin:0 0 0.5rem 0; color:#f1f5f9;">Night Action</h3>
      <div style="margin-bottom:0.5rem;">
        <label class="small">Choose target</label>
        <div id="nightTargets" style="display:grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap:8px; margin-top:0.5rem; max-height:360px; overflow:auto; padding-right:6px;"></div>
      </div>
      <div style="display:flex; gap:0.5rem; justify-content:flex-end;">
        <button class="btn" onclick="closeNightModal()">Close</button>
        <!-- backup submit button (hidden) kept for compatibility with older flows -->
        <button class="btn btn-primary" id="nightSubmitBtn" style="display:none;" onclick="submitNightAction()">Submit</button>
      </div>
    </div>
  </div>

  <!-- Elimination overlay -->
  <div class="elimination-overlay" id="eliminationOverlay">
    <div class="elimination-message">
      <div class="elimination-title">💀</div>
      <div class="elimination-text">You have been eliminated!</div>
      <div class="elimination-status">ELIMINATED</div>
      <p style="color: #94a3b8; margin-top: 2rem;">
        You can continue to watch the game, but you can no longer participate.
      </p>
      <button class="btn btn-primary" onclick="window.location.href='/watch/' + encodeURIComponent(ROOM_NAME)" style="margin-top: 1rem;">
        Continue Watching
      </button>
    </div>
  </div>

  <!-- Suicide bomber prompt modal (shown only to the bomber if lynched) -->
  <div id="suicideModal" style="display:none; position:fixed; left:0; top:0; width:100%; height:100%; background:rgba(0,0,0,0.6); align-items:center; justify-content:center; z-index:1250;">
    <div style="background:#0b1220; padding:1rem 1.25rem; border-radius:10px; width:420px; border:1px solid rgba(255,255,255,0.04);">
      <h3 style="margin:0 0 0.5rem 0; color:#f1f5f9;">Final Act — Choose a Target</h3>
      <div style="margin-bottom:0.5rem; color:#cbd5e1;">You have been lynched and your role allows a final act. Choose one player to eliminate with you.</div>
      <div id="suicideChoices" style="display:flex; flex-direction:column; gap:0.5rem; max-height:240px; overflow:auto; margin-top:0.5rem;"></div>
      <div style="display:flex; gap:0.5rem; justify-content:flex-end; margin-top:0.75rem;">
        <button class="btn" onclick="closeSuicideModal()">Skip</button>
        <button class="btn btn-danger" id="suicideSubmitBtn" onclick="submitSuicideChoice()">Submit</button>
      </div>
    </div>
  </div>

  <!-- Voting modal shown to the current voter when a voting session is active -->
  <div id="votingModal" style="display:none; position:fixed; left:0; top:0; width:100%; height:100%; background:rgba(0,0,0,0.6); align-items:center; justify-content:center; z-index:1260;">
    <div style="background:#0b1220; padding:1rem 1.25rem; border-radius:10px; width:520px; border:1px solid rgba(255,255,255,0.04);">
      <h3 style="margin:0 0 0.5rem 0; color:#f1f5f9;">Voting — It's your turn</h3>
      <div style="margin-bottom:0.5rem; color:#cbd5e1;">Select a player to vote for lynching. The host and other players can watch who is voting and the running vote log.</div>
      <div id="votingChoices" style="display:flex; flex-direction:column; gap:0.5rem; max-height:320px; overflow:auto; margin-top:0.5rem;"></div>
      <div style="display:flex; gap:0.5rem; justify-content:flex-end; margin-top:0.75rem;">
        <button class="btn" onclick="closeVotingModal()">Skip</button>
      </div>
    </div>
  </div>

  <!-- Action confirmation modal -->
  <div id="actionConfirmModal" style="display:none; position:fixed; left:0; top:0; width:100%; height:100%; background:rgba(0,0,0,0.6); align-items:center; justify-content:center; z-index:1220;">
    <div style="background:#0b1220; padding:1rem 1.25rem; border-radius:10px; width:420px; border:1px solid rgba(255,255,255,0.04);">
      <h3 id="actionConfirmTitle" style="margin:0 0 0.5rem 0; color:#f1f5f9;">Confirm Action</h3>
      <div id="actionConfirmText" style="margin-bottom:0.75rem; color:#cbd5e1;"></div>
      <div style="display:flex; gap:0.5rem; justify-content:flex-end;">
        <button class="btn" onclick="closeActionConfirm()">Cancel</button>
        <button class="btn btn-danger" id="confirmActionBtn">Confirm</button>
      </div>
    </div>
  </div>

  <!-- Toast notification for brief messages before redirects -->
  <div id="toast" style="display:none; position: fixed; left: 50%; transform: translateX(-50%); bottom: 12vh; background: rgba(0,0,0,0.7); color: #fff; padding: 0.8rem 1.2rem; border-radius: 8px; font-weight: 700; box-shadow: 0 6px 20px rgba(0,0,0,0.5); z-index: 1100;">
    <span id="toastMessage">Message</span>
  </div>

  <!-- Role avatar one-shot overlay (shows when a player first gets their role) -->
  <div class="role-avatar-overlay" id="roleAvatarOverlay" aria-hidden="true" style="display:none; position:fixed; inset:0; align-items:center; justify-content:center; background: rgba(2,6,23,0.78); z-index:2200;">
    <div class="role-avatar-card" id="roleAvatarCard" style="background:#071027; padding:1.25rem 1.5rem; border-radius:14px; display:flex; flex-direction:column; align-items:center; gap:0.6rem; max-width:460px; width:min(92%,460px); box-shadow: 0 18px 50px rgba(2,6,23,0.75); border:1px solid rgba(255,255,255,0.03);">
      <div class="role-avatar-image" id="roleAvatarImage" style="width:140px; height:140px; overflow:hidden; border-radius:14px; background:#071028; display:flex; align-items:center; justify-content:center;">
        <img id="roleAvatarImg" src="/static/mafia_role_avatars/default.svg" alt="avatar" width="128" height="128" style="border-radius:10px; display:block; max-width:100%; height:auto;"/>
      </div>
      <div style="font-weight:900; font-size:1.05rem;">Welcome, <span id="roleAvatarName"></span></div>
      <div style="color:#94a3b8;">Role: <span id="roleAvatarRole"></span></div>
    </div>
  </div>

  <div class="footer">
    Created by Scissors. Powered by Sunisha and Diet Coke
  </div>

  <script>
    const PLAYER_NAME = '{{ name | e }}';
    const ROOM_NAME = '{{ room_name | e }}';
    
  let isEliminated = false;
  let hasShownEliminationMessage = false;
  // Persist last-known voting snapshot on the client so the voting dashboard
  // remains visible until the next Day phase begins (server-driven).
  let persistentVotingSnapshot = null;
  let lastSeenPhaseForVoting = null;
  // Track which voter we've already announced to avoid duplicate announcements
  let lastAnnouncedVoter = null;

    function escapeHtml(str) {
      const p = document.createElement('p');
      p.innerText = str;
      return p.innerHTML;
    }

    function showToast(msg, ms = 1200) {
      try {
        const toast = document.getElementById('toast');
        const msgEl = document.getElementById('toastMessage');
        msgEl.textContent = msg;
        toast.style.display = 'block';
        // fade in
        toast.style.opacity = 0;
        toast.style.transition = 'opacity 160ms ease';
        requestAnimationFrame(() => { toast.style.opacity = 1; });
        setTimeout(() => {
          // fade out
          toast.style.opacity = 0;
          setTimeout(() => { toast.style.display = 'none'; }, 220);
        }, ms);
      } catch (e) { console.warn('Toast failed', e); }
    }

    function showEliminationOverlay() {
      if (!hasShownEliminationMessage) {
        document.getElementById('eliminationOverlay').style.display = 'flex';
        hasShownEliminationMessage = true;
      }
    }

    function hideEliminationOverlay() {
      document.getElementById('eliminationOverlay').style.display = 'none';
    }

    // Role visibility toggle
    let roleVisible = true;
    function toggleRoleVisibility() {
      try {
        roleVisible = !roleVisible;
        const roleBadge = document.getElementById('roleBadge');
        const roleDescription = document.getElementById('roleDescription');
        const toggleBtn = document.getElementById('toggleRoleBtn');
        const warningMessage = document.getElementById('warningMessage');
        const teammatesSection = document.getElementById('visibleTeammatesSection');
        const teammatesList = document.getElementById('visibleTeammatesList');
        // faction badges shown on this screen (e.g., next to roleBadge and teammates)
        const factionBadges = document.querySelectorAll('.faction-unified');
        if (roleVisible) {
          if (roleBadge) roleBadge.style.display = 'block';
          if (roleDescription) roleDescription.style.display = 'block';
          if (warningMessage) warningMessage.style.display = 'block';
          // only show teammates section if it actually has items
          if (teammatesSection && teammatesList && teammatesList.children && teammatesList.children.length) {
            teammatesSection.style.display = 'block';
          }
          // show faction badges (restore default display)
          if (factionBadges && factionBadges.length) {
            factionBadges.forEach(b => { b.style.display = ''; });
          }
          if (toggleBtn) toggleBtn.textContent = 'Hide Role';
        } else {
          if (roleBadge) roleBadge.style.display = 'none';
          if (roleDescription) roleDescription.style.display = 'none';
          if (warningMessage) warningMessage.style.display = 'none';
          // hide the teammates section when the role is hidden (useful for mafia players)
          if (teammatesSection) teammatesSection.style.display = 'none';
          // hide faction badges when role hidden
          if (factionBadges && factionBadges.length) {
            factionBadges.forEach(b => { b.style.display = 'none'; });
          }
          if (toggleBtn) toggleBtn.textContent = 'Show Role';
        }
      } catch (e) { console.warn('toggleRoleVisibility failed', e); }
    }

    function updateEliminationStatus(eliminated) {
      const gameCard = document.getElementById('gameCard');
      const playerName = document.getElementById('playerName');
      const roleBadge = document.getElementById('roleBadge');
      const roleDescription = document.getElementById('roleDescription');
      const statusIndicator = document.getElementById('statusIndicator');
      const warningMessage = document.getElementById('warningMessage');

      if (eliminated && !isEliminated) {
        // Player just got eliminated
        isEliminated = true;
        
        // Update visual elements
        gameCard.classList.add('eliminated');
        playerName.classList.add('eliminated');
        roleBadge.classList.add('eliminated');
        roleDescription.classList.add('eliminated');
        
        statusIndicator.textContent = 'ELIMINATED 💀';
        statusIndicator.className = 'status-indicator status-eliminated';
        
        warningMessage.innerHTML = '💀 You have been eliminated from the game!';
        warningMessage.style.background = '#4c1d1d';
        warningMessage.style.color = '#f87171';
        warningMessage.style.borderColor = '#dc2626';
        
        // Show elimination overlay
        showEliminationOverlay();
        
      } else if (!eliminated && isEliminated) {
        // Player was revived (unlikely but possible)
        isEliminated = false;
        
        // Remove elimination styling
        gameCard.classList.remove('eliminated');
        playerName.classList.remove('eliminated');
        roleBadge.classList.remove('eliminated');
        roleDescription.classList.remove('eliminated');
        
        statusIndicator.textContent = 'ALIVE';
        statusIndicator.className = 'status-indicator status-alive';
        
        warningMessage.innerHTML = "🤫 Keep your role secret! Don't let other players see this screen.";
        warningMessage.style.background = '#451a03';
        warningMessage.style.color = '#fbbf24';
        warningMessage.style.borderColor = '#92400e';
        
        hideEliminationOverlay();
      }
    }

    async function checkEliminationStatus() {
      try {
        const response = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/players`, {
          cache: 'no-store'
        });
        
        if (!response.ok) {
          throw new Error('Failed to fetch player status');
        }
        
        const data = await response.json();
  const eliminatedPlayers = data.eliminated_players || [];
        const isPlayerEliminated = eliminatedPlayers.includes(PLAYER_NAME);
        
        updateEliminationStatus(isPlayerEliminated);

        // If server indicates a pending suicide prompt for this player, render the modal choices
        try {
          const sp = data.suicide_prompt || { active: false };
          if (sp && sp.active) {
            // populate and show modal
            renderSuicideChoices(sp.choices || []);
            document.getElementById('suicideModal').style.display = 'flex';
          }
        } catch (e) { console.warn('suicide prompt render error', e); }

        // If the host has restarted the game, assignments may be cleared and game_started will be false.
        // In that case, redirect this player back to the waiting/thanks page so they see the lobby.
        const gameStarted = !!data.game_started;
        const assignments = data.assignments || {};
        const hasAssignment = Object.prototype.hasOwnProperty.call(assignments, PLAYER_NAME);
        if (!gameStarted || !hasAssignment) {
          // Show a brief toast so player understands what's happening, then redirect back to the lobby/waiting page
          showToast('Host restarted the game — returning to lobby...', 1400);
          setTimeout(() => {
            window.location.replace(`/room/${encodeURIComponent(ROOM_NAME)}`);
          }, 1400);
          return;
        }
        
        // Update last checked time
        const now = new Date();
        document.getElementById('lastUpdated').textContent = 
          'Last checked: ' + now.toLocaleTimeString();

        // show winner banner if game over
        try {
          const gsResp = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/game-state`, { cache: 'no-store' });
          if (gsResp && gsResp.ok) {
            const gs = await gsResp.json();
            if (gs && gs.game_over) {
              const wb = document.getElementById('winnerBannerPlayer');
              const wbt = document.getElementById('winnerBannerText');
              if (wb && wbt) {
                wbt.textContent = 'Winner: ' + (gs.winner || '—');
                wb.style.display = 'block';
                if ((gs.winner || '').toLowerCase() === 'mafia') wb.style.background = 'linear-gradient(90deg,#7f1d1d,#b91c1c)';
                else if ((gs.winner || '').toLowerCase() === 'villagers') wb.style.background = 'linear-gradient(90deg,#064e3b,#059669)';
                else wb.style.background = '#111';
              }
            }
          }
        } catch (e) { /* non-fatal */ }

        // Populate read-only moderator dashboard from players response if available
        try {
          const pdPhase = document.getElementById('pdPhase');
          const pdNightStep = document.getElementById('pdNightStep');
          const pdLastKilled = document.getElementById('pdLastKilled');
          const pdLastMuted = document.getElementById('pdLastMuted');
          const pdLastEvents = document.getElementById('pdLastEvents');
          // If server indicates interactive_mode is false, hide phase/night info from players
          const interactive = (typeof data.interactive_mode === 'undefined') ? true : !!data.interactive_mode;
          if (!interactive) {
            // hide phase info
            if (pdPhase) pdPhase.textContent = '—';
            if (pdNightStep) pdNightStep.textContent = '—';
            if (pdLastKilled) pdLastKilled.textContent = '—';
            if (pdLastMuted) pdLastMuted.textContent = '—';
            if (pdLastEvents) pdLastEvents.textContent = '—';
          } else {
            if (pdPhase) pdPhase.textContent = data.phase || '—';
            if (pdNightStep) pdNightStep.textContent = data.current_night_step ? (data.current_night_step.name || '') + (data.current_night_step.index != null ? ` (step ${data.current_night_step.index})` : '') : '—';
            const killedList = (data.last_night_killed && data.last_night_killed.length) ? data.last_night_killed : (data.last_night_events && data.last_night_events.killed ? data.last_night_events.killed : []);
            const mutedVal = (data.last_night_muted !== undefined && data.last_night_muted !== null) ? data.last_night_muted : (data.last_night_events ? data.last_night_events.muted : null);
            if (pdLastKilled) pdLastKilled.textContent = (killedList && killedList.length) ? killedList.join(', ') : '—';
            if (pdLastMuted) pdLastMuted.textContent = (mutedVal) ? mutedVal : '—';
            if (pdLastEvents) {
              const parts = [];
              if (killedList && killedList.length) parts.push('<b>Killed:</b> ' + killedList.join(', '));
              if (mutedVal) parts.push('<b>Muted:</b> ' + mutedVal);
              pdLastEvents.innerHTML = parts.length ? parts.join('<br>') : '—';
              // If server provided reveal details for last night events, append them to elimination log
              try {
                const reveals = (data.last_night_events && data.last_night_events.reveals) ? data.last_night_events.reveals : [];
                if (reveals && reveals.length) {
                  reveals.forEach(r => {
                    appendEliminationLogEntry({ time: r.time || new Date().toLocaleTimeString(), text: (r.text || `${r.name} — ${r.role} (${r.cause || 'killed'})`) });
                  });
                }
              } catch(e) { /* non-fatal */ }
            }
          }
        } catch (e) { /* ignore dashboard binding errors */ }
        // Voting UI: persistent voting dashboard (separate from last events)
        try {
          const voting = data.voting || null;
          const vd = document.getElementById('votingDashboard');
          const vdStatus = document.getElementById('votingStatus') || document.getElementById('vdVotingStatus');
          const vdCurrent = document.getElementById('votingCurrent') || document.getElementById('vdCurrentVoter');
          const vdTally = document.getElementById('votingTally') || document.getElementById('vdTally');
          const vdLog = document.getElementById('votingLog') || document.getElementById('vdVoteLog');

          function renderTally(tally) {
            if (!vdTally) return;
            vdTally.innerHTML = '';
            if (!tally || Object.keys(tally).length === 0) {
              vdTally.textContent = '—';
              return;
            }
            const entries = Object.entries(tally).filter(([k,c]) => (c||0) > 0).sort((a,b)=> b[1]-a[1] || a[0].localeCompare(b[0]));
            vdTally.innerHTML = entries.map(([name,count]) => `<div style="display:flex; justify-content:space-between; margin-bottom:0.25rem;
                padding:0.25rem 0;">
                <span>${escapeHtml(name)}</span>
                <strong>${count}</strong>
              </div>`).join('');
          }

          function renderLog(votes_log) {
            if (!vdLog) return;
            if (!votes_log || !votes_log.length) {
              vdLog.textContent = '—';
              return;
            }
            const log = votes_log.slice(-20);
            vdLog.innerHTML = log.map(l => `<div style="margin-bottom:0.25rem;">${escapeHtml(l.voter || l.from || '')} → <strong>${escapeHtml(l.choice || l.to || '')}</strong></div>`).join('');
          }

          // Update persistent snapshot and render. The client persists the last-known voting snapshot
          // until the server announces the Day phase (per requirement).
          if (voting) {
            // If server explicitly indicates a reset, clear the persistent snapshot immediately.
            if (voting.reset) {
              persistentVotingSnapshot = null;
              if (vd) vd.style.display = 'none';
              if (vdStatus) vdStatus.textContent = '—';
              if (vdCurrent) vdCurrent.textContent = '—';
              if (vdTally) vdTally.textContent = '—';
              if (vdLog) vdLog.textContent = '—';
            } else {
              // Always refresh the persistent snapshot with any voting info we receive from server
              const wasActive = persistentVotingSnapshot && persistentVotingSnapshot.active;
              persistentVotingSnapshot = voting;
              try { if (!wasActive && persistentVotingSnapshot && persistentVotingSnapshot.active) showVotingBanner('Voting has started', 2200); } catch(e) {}
            }
          }

          // Only clear the persistent snapshot when we observe a full night->day transition.
          // This ensures the voting dashboard persists for the remainder of the day after voting ends.
          const phaseLower = data.phase ? data.phase.toLowerCase() : null;
          if (phaseLower === 'day' && lastSeenPhaseForVoting && lastSeenPhaseForVoting.toLowerCase() === 'night') {
            // We have seen a night since the last snapshot — clear it now at start of the new day
            persistentVotingSnapshot = null;
            if (vd) vd.style.display = 'none';
            if (vdStatus) vdStatus.textContent = '—';
            if (vdCurrent) vdCurrent.textContent = '—';
            if (vdTally) vdTally.textContent = '—';
            if (vdLog) vdLog.textContent = '—';
          } else if (persistentVotingSnapshot) {
            // Render the last-known snapshot and keep it visible until Day phase arrives
            if (vd) vd.style.display = 'block';
            if (vdStatus) vdStatus.textContent = (persistentVotingSnapshot.active ? 'ACTIVE' : 'ENDED');
            if (vdCurrent) vdCurrent.textContent = persistentVotingSnapshot.current_voter || '—';
            renderTally(persistentVotingSnapshot.tally || {});
            renderLog(persistentVotingSnapshot.votes_log || []);

            // If it's this player's turn (snapshot may indicate current_voter), show voting modal
            if (persistentVotingSnapshot.current_voter === PLAYER_NAME && persistentVotingSnapshot.active) {
              const aliveChoices = data.players.filter(p => !(data.eliminated_players||[]).includes(p));
              renderVotingChoices(aliveChoices);
              try { document.getElementById('votingModal').style.display = 'flex'; } catch(e) {}
              // Announce only once per voter turn
              try {
                if (lastAnnouncedVoter !== persistentVotingSnapshot.current_voter) {
                  lastAnnouncedVoter = persistentVotingSnapshot.current_voter;
                  speak("It's your turn to vote. Please select a player and confirm your vote.");
                  try {
                    // Vibrate once on mobile devices when it's the player's turn
                    if (isMobileDevice() && 'vibrate' in navigator) {
                      try { navigator.vibrate(200); } catch (e) { /* non-fatal */ }
                    }
                  } catch (e) { /* ignore vibration errors */ }
                }
              } catch(e) {}
            }
          } else {
            // No snapshot and not Day — keep dashboard hidden
            if (vd) vd.style.display = 'none';
          }

          // remember last seen phase for potential future logic
          lastSeenPhaseForVoting = data.phase || lastSeenPhaseForVoting;
        } catch (e) { console.warn('Voting dashboard update failed', e); }
        // Render visible teammates if provided (e.g., mafia members)
        try {
          const visible = data.visible_roles || [];
          const section = document.getElementById('visibleTeammatesSection');
          const list = document.getElementById('visibleTeammatesList');
          if (visible && visible.length && roleVisible) {
            section.style.display = 'block';
            list.innerHTML = '';
            visible.forEach(v => {
              const el = document.createElement('div');
              el.style.display = 'flex';
              el.style.justifyContent = 'space-between';
              el.style.alignItems = 'center';
              el.style.padding = '0.5rem';
              el.style.background = '#111827';
              el.style.borderRadius = '8px';
              el.innerHTML = `<strong>${escapeHtml(v.name)}</strong><span class="faction-badge faction-unified">${escapeHtml(v.role)}</span>`;
              list.appendChild(el);
            });
          } else {
            section.style.display = 'none';
            list.innerHTML = '';
          }
        } catch (e) { console.warn('Could not render visible teammates', e); }
        
      } catch (error) {
        console.error('Error checking elimination status:', error);
        document.getElementById('lastUpdated').textContent = 
          'Last checked: Error connecting to server';
      }
    }

    // Check elimination status immediately and then every 3 seconds
    checkEliminationStatus();
    setInterval(checkEliminationStatus, 3000);

  // Speech is automatic; no explicit init required

    // Suicide modal helpers
    function renderSuicideChoices(choices) {
      const container = document.getElementById('suicideChoices');
      // remember previously selected choice (if any) so we can restore it after re-render
      const prevSelected = container && container.dataset && container.dataset.selected ? container.dataset.selected : '';
      container.innerHTML = '';
      // disable submit until a selection is made
      try { document.getElementById('suicideSubmitBtn').disabled = true; } catch(e) {}
      if (!choices || !choices.length) {
        const p = document.createElement('div'); p.textContent = 'No valid targets available.'; container.appendChild(p); return;
      }
      for (const c of choices) {
        const el = document.createElement('div');
        el.className = 'suicide-choice';
        el.tabIndex = 0;
        el.dataset.name = c;

        const name = document.createElement('div');
        name.className = 'name';
        name.textContent = c;

        const check = document.createElement('div');
        check.className = 'check hidden';
        check.innerHTML = '✓';

        el.appendChild(name);
        el.appendChild(check);

        // click and keyboard support
        const selectFn = () => {
          if (el.classList.contains('disabled')) return;
          // clear previous
          Array.from(container.querySelectorAll('.suicide-choice')).forEach(s => {
            s.classList.remove('selected');
            const ch = s.querySelector('.check'); if (ch) ch.classList.add('hidden');
          });
          el.classList.add('selected');
          const ch = el.querySelector('.check'); if (ch) ch.classList.remove('hidden');
          container.dataset.selected = c;
          try { document.getElementById('suicideSubmitBtn').disabled = false; } catch(e) {}
          // keep focus on the selected element so keyboard users see persistent highlight
          try { el.focus(); } catch(e) {}
        };

        el.addEventListener('click', selectFn);
        el.addEventListener('keydown', (ev) => { if (ev.key === 'Enter' || ev.key === ' ') { ev.preventDefault(); selectFn(); } });

        container.appendChild(el);
      }
      // restore previous selection if it still exists in the new choices
      try {
        if (prevSelected) {
          const restored = Array.from(container.querySelectorAll('.suicide-choice')).find(s => s.dataset && s.dataset.name === prevSelected);
          if (restored) {
            // simulate selection without re-triggering event handlers
            restored.classList.add('selected');
            const ch = restored.querySelector('.check'); if (ch) ch.classList.remove('hidden');
            container.dataset.selected = prevSelected;
            try { document.getElementById('suicideSubmitBtn').disabled = false; } catch(e) {}
            try { restored.focus(); } catch(e) {}
          }
        }
      } catch (e) { /* non-fatal */ }
    }

    function closeSuicideModal() {
      try { 
        const modal = document.getElementById('suicideModal');
        modal.style.display = 'none'; 
        // clear selection
        const container = document.getElementById('suicideChoices');
        if (container) { container.innerHTML = ''; container.dataset.selected = ''; }
        try { document.getElementById('suicideSubmitBtn').disabled = true; } catch(e) {}
      } catch (e) {}
    }

    async function submitSuicideChoice() {
      try {
        const container = document.getElementById('suicideChoices');
        const selected = container && container.dataset && container.dataset.selected ? container.dataset.selected : null;
        if (!selected) { alert('Select a player to eliminate with you'); return; }
        const form = new URLSearchParams();
        form.append('target', selected);
        const resp = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/suicide`, { method: 'POST', headers: {'Content-Type':'application/x-www-form-urlencoded'}, body: form.toString() });
        const d = await resp.json();
        if (d && d.success) {
          showToast('Final act submitted — you have been eliminated', 1600);
          // after a short delay redirect to watch page (eliminated view)
          setTimeout(() => { window.location.replace(`/watch/${encodeURIComponent(ROOM_NAME)}`); }, 1600);
        } else {
          alert('Submission failed: ' + (d.error || 'unknown'));
        }
      } catch (e) {
        console.error('submitSuicideChoice error', e);
        alert('Error submitting final act');
      }
    }

    // Voting modal helpers
    function renderVotingChoices(choices) {
      const container = document.getElementById('votingChoices');
      container.innerHTML = '';
      if (!choices || !choices.length) {
        const p = document.createElement('div'); p.textContent = 'No players available to vote for.'; container.appendChild(p); return;
      }
      for (const c of choices) {
        const el = document.createElement('div');
        el.className = 'suicide-choice'; // reuse style for compact tiles
        el.tabIndex = 0;
        el.dataset.name = c;

        const name = document.createElement('div');
        name.className = 'name';
        name.textContent = c;

        const btn = document.createElement('button');
        btn.className = 'btn btn-danger';
        btn.textContent = 'Vote';
        btn.onclick = () => { if (confirm(`Confirm vote for ${c}?`)) submitVote(c); };

        el.appendChild(name);
        el.appendChild(btn);
        container.appendChild(el);
      }
    }

    function closeVotingModal() {
      try { document.getElementById('votingModal').style.display = 'none'; } catch(e) {}
    }

    // Voting banner helpers (animated)
    let votingBannerTimeout = null;
    function showVotingBanner(text, duration = 2500) {
      try {
        const b = document.getElementById('votingBanner');
        b.textContent = text || 'Voting Started — Participate Now';
        b.classList.add('show');
        if (votingBannerTimeout) clearTimeout(votingBannerTimeout);
        votingBannerTimeout = setTimeout(() => { hideVotingBanner(); }, duration);
        // voting banner shown for everyone; per-player announcement handled elsewhere
      } catch (e) { console.warn('voting banner failed', e); }
    }
    function hideVotingBanner() { try { const b = document.getElementById('votingBanner'); if (b) b.classList.remove('show'); } catch(e) {} }

    // Reveal overlay helpers
    function showRevealOverlay({ name, role, cause, logEntries }) {
      try {
        const overlay = document.getElementById('revealOverlay');
        if (!overlay) return;
        document.getElementById('revealName').textContent = name || '';
        document.getElementById('revealRole').textContent = role || '';
        document.getElementById('revealCause').textContent = cause || '';
        // populate elimination log
        const log = document.getElementById('eliminationLog');
        if (log) {
          log.innerHTML = '';
          (logEntries||[]).forEach(e => {
            const div = document.createElement('div'); div.className = 'log-entry';
            const t = document.createElement('time'); t.textContent = e.time || '';
            const txt = document.createElement('span'); txt.innerHTML = e.text || '';
            div.appendChild(t); div.appendChild(txt);
            log.appendChild(div);
          });
        }
        overlay.style.display = 'flex';
        const card = overlay.querySelector('.reveal-card');
        if (card) { card.classList.remove('pop'); void card.offsetWidth; card.classList.add('pop'); }
      } catch (e) { console.warn('showRevealOverlay failed', e); }
    }
    function hideRevealOverlay() { try { const overlay = document.getElementById('revealOverlay'); if (overlay) overlay.style.display = 'none'; } catch(e) {} }
    function appendEliminationLogEntry(entry) {
      try {
        const log = document.getElementById('eliminationLog');
        if (!log) return;
        const div = document.createElement('div'); div.className = 'log-entry';
        const t = document.createElement('time'); t.textContent = entry.time || new Date().toLocaleTimeString();
        const txt = document.createElement('span'); txt.innerHTML = entry.text || '';
        div.appendChild(t); div.appendChild(txt);
        log.appendChild(div);
      } catch (e) { console.warn('appendEliminationLogEntry failed', e); }
    }
    function copyEliminationLog() {
      try {
        const log = document.getElementById('eliminationLog'); if (!log) return;
        const text = Array.from(log.querySelectorAll('.log-entry')).map(le => le.textContent.trim()).join('\n');
        navigator.clipboard.writeText(text).then(() => { showToast('Log copied'); }).catch(() => { showToast('Copy failed'); });
      } catch (e) { console.warn('copyEliminationLog error', e); }
    }

    // ---------------- Speech synthesis for voting notifications ----------------
    // No speech opt-in checkbox anymore. Voices will be resolved by speak().

    // global mute state (read from localStorage)
    function isSiteMuted() {
      try { return localStorage.getItem('siteMuted') === '1'; } catch(e) { return false; }
    }

    // Mobile detection helper (used for vibration)
    function isMobileDevice() {
      try {
        return /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent || '');
      } catch (e) { return false; }
    }

    // Robust speak(): prefer female voice, queue until voices are available, cache preferred voice
    (function() {
      let preferredVoice = null;
      let voicesResolved = false;
      const speakQueue = [];

      function resolvePreferredVoice() {
        try {
          const voices = window.speechSynthesis.getVoices() || [];
          if (!voices || !voices.length) return null;
          // heuristic list of female voice name fragments
          const femaleRegex = /female|woman|samantha|emma|amy|joanna|ivy|salli|nicole|kendra|rita|maria|lisa/i;
          let found = voices.find(v => femaleRegex.test(v.name || ''));
          if (!found) {
            const lang = (navigator.language || navigator.userLanguage || '').split('-')[0];
            found = voices.find(v => v.lang && v.lang.startsWith(lang));
          }
          if (!found) found = voices[0];
          return found || null;
        } catch (e) {
          return null;
        }
      }

      function flushQueue() {
        if (!voicesResolved) return;
        while (speakQueue.length) {
          const txt = speakQueue.shift();
          _doSpeak(txt);
        }
      }

      function _doSpeak(text) {
        try {
          if (isSiteMuted()) return;
          if (!('speechSynthesis' in window)) return;
          const u = new SpeechSynthesisUtterance(text);
          if (preferredVoice) u.voice = preferredVoice;
          u.rate = 1.0; u.pitch = 1.0;
          try { window.speechSynthesis.cancel(); } catch(e) {}
          window.speechSynthesis.speak(u);
        } catch (e) { console.warn('speak failed', e); }
      }

      // Public speak function used in templates
      window.speak = function(text) {
        try {
          if (isSiteMuted()) return;
          if (!('speechSynthesis' in window)) return;
          // If voices aren't resolved yet, queue the text and trigger resolution
          if (!voicesResolved) {
            speakQueue.push(text);
            // attempt to resolve immediately
            preferredVoice = resolvePreferredVoice();
            if (preferredVoice) {
              voicesResolved = true;
              flushQueue();
            }
            return;
          }
          _doSpeak(text);
        } catch (e) { console.warn('speak failed', e); }
      };

      // Listen for voiceschanged to resolve and flush queue
      try {
        const onVoicesChanged = () => {
          if (!voicesResolved) {
            preferredVoice = resolvePreferredVoice();
            voicesResolved = true;
            flushQueue();
          }
        };
        window.speechSynthesis.addEventListener('voiceschanged', onVoicesChanged);
        // try immediate resolution in case voices are already available
        preferredVoice = resolvePreferredVoice();
        if (preferredVoice) {
          voicesResolved = true;
          flushQueue();
        }
      } catch (e) { /* non-fatal */ }
    })();

    async function submitVote(choice) {
      try {
        const form = new URLSearchParams();
        form.append('choice', choice);
        const resp = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/vote`, { method: 'POST', headers: {'Content-Type':'application/x-www-form-urlencoded'}, body: form.toString() });
        const d = await resp.json();
        if (d && d.success) {
          showToast('Vote submitted', 900);
          closeVotingModal();
          try { speak('You voted for ' + choice + '.'); } catch(e) {}
          // refresh immediately so players and host see updated log/tally
          setTimeout(() => { checkEliminationStatus(); }, 250);
        } else {
          alert('Vote failed: ' + (d.error || 'unknown'));
        }
      } catch (e) {
        console.error('submitVote error', e);
        alert('Error submitting vote');
      }
    }

  // Night action handling
  let lastKnownPhase = null;
  let lastKnownNightIndex = null;
  let pendingActionType = null;
  // Remember the last action the client submitted (to avoid re-prompting for same step)
  let lastActionSubmitted = null; // { step: index, action: 'sheriff_mute' }
  // Step index that was shown when the modal was opened
  let lastShownStepIndex = null;
  // Prevent overlapping prompt renders
  let promptInProgress = false;

    function closeNightModal() {
      const modal = document.getElementById('nightModal');
      try { if (modal && modal.dataset) modal.dataset.opened = '0'; } catch(e) {}
      try { modal.style.display = 'none'; } catch(e) {}
      promptInProgress = false;
    }

    async function submitNightAction() {
      // Legacy single-submit fallback (kept for compatibility)
      const target = document.getElementById('nightTarget') ? (document.getElementById('nightTarget').value || '') : '';
      if (!pendingActionType) { alert('No action in progress'); return; }
      await submitNightActionTo(target, pendingActionType);
    }

    // Submit an action to the server for the given target and actionType.
    async function submitNightActionTo(target, actionType) {
      if (!actionType) { alert('No action type specified'); return; }
      try {
        const body = `action_type=${encodeURIComponent(actionType)}&target=${encodeURIComponent(target || '')}`;
        const resp = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/action`, { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded' }, body });
        const d = await resp.json();
          // fetch game-state and update read-only dashboard
          try {
            const gsResp = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/game-state`, { cache: 'no-store' });
            if (gsResp && gsResp.ok) {
              const gs = await gsResp.json();
              const pdPhase = document.getElementById('pdPhase');
              const pdNightStep = document.getElementById('pdNightStep');
              const pdLastKilled = document.getElementById('pdLastKilled');
              const pdLastMuted = document.getElementById('pdLastMuted');
              const pdLastEvents = document.getElementById('pdLastEvents');
              if (pdPhase) pdPhase.textContent = gs.phase || '—';
              if (pdNightStep) pdNightStep.textContent = gs.current_night_step ? (gs.current_night_step.name || '') + (gs.current_night_step.index != null ? ` (step ${gs.current_night_step.index})` : '') : '—';
              const killedList = (gs.last_night_killed && gs.last_night_killed.length) ? gs.last_night_killed : (gs.last_night_events && gs.last_night_events.killed ? gs.last_night_events.killed : []);
              const mutedVal = (gs.last_night_muted !== undefined && gs.last_night_muted !== null) ? gs.last_night_muted : (gs.last_night_events ? gs.last_night_events.muted : null);
              if (pdLastKilled) pdLastKilled.textContent = (killedList && killedList.length) ? killedList.join(', ') : '—';
              if (pdLastMuted) pdLastMuted.textContent = (mutedVal) ? mutedVal : '—';
              if (pdLastEvents) {
                const parts = [];
                const killedParts = (gs.last_night_killed && gs.last_night_killed.length) ? gs.last_night_killed : (gs.last_night_events && gs.last_night_events.killed ? gs.last_night_events.killed : []);
                const mutedPart = (gs.last_night_muted !== undefined && gs.last_night_muted !== null) ? gs.last_night_muted : (gs.last_night_events ? gs.last_night_events.muted : null);
                if (killedParts && killedParts.length) parts.push('<b>Killed:</b> ' + killedParts.join(', '));
                if (mutedPart) parts.push('<b>Muted:</b> ' + mutedPart);
                pdLastEvents.innerHTML = parts.length ? parts.join('<br>') : '—';
              }
            }
          } catch (e) {
            // ignore game-state fetch errors for player dashboard
          }
        if (d.success) {
          showToast('Action submitted', 1000);
          if (d.cop_result) {
            const r = d.cop_result;
            alert(`Investigation result:\n${r.checked} → ${r.result}`);
          }
          // close modal and clear pending action
          closeNightModal();
          try { const modalEl = document.getElementById('nightModal'); if (modalEl && modalEl.dataset) modalEl.dataset.opened = '0'; } catch(e) {}
          // record submitted action so we don't re-prompt for the same step/action
          try { lastActionSubmitted = { step: (lastShownStepIndex != null ? lastShownStepIndex : null), action: actionType }; } catch(e) { lastActionSubmitted = { step: null, action: actionType }; }
          pendingActionType = null;
          // mark target tile acted and disable its buttons
          try {
            const targetsEl = document.getElementById('nightTargets');
            if (targetsEl) {
              const tiles = Array.from(targetsEl.querySelectorAll('.target-tile'));
              for (const t of tiles) {
                const n = t.querySelector('div') && t.querySelector('div').textContent && t.querySelector('div').textContent.trim();
                if (n === target) {
                  t.classList.add('disabled');
                  // add checkmark badge
                  if (!t.querySelector('.tile-checkmark-badge')) {
                    const cb = document.createElement('div'); cb.className = 'tile-checkmark-badge'; cb.textContent = '✓';
                    // position relative container
                    t.style.position = 'relative';
                    t.appendChild(cb);
                  }
                  // disable buttons inside
                  t.querySelectorAll('button').forEach(b => b.disabled = true);
                }
              }
            }
          } catch (e) { /* ignore UI update errors */ }
        } else {
          alert('Action failed: ' + (d.error || 'unknown'));
        }
      } catch (e) {
        console.error('submitNightActionTo error', e);
        alert('Error submitting action');
      }
    }

    function openActionConfirm(target, actionType, onConfirm) {
      const title = document.getElementById('actionConfirmTitle');
      const text = document.getElementById('actionConfirmText');
      title.textContent = 'Confirm ' + (actionType || '').replace(/_/g,' ').replace(/\b\w/g, c=>c.toUpperCase());
      text.textContent = `Are you sure you want to ${ (actionType||'').replace(/_/g,' ') } ${target || ''}? This cannot be undone.`;
      document.getElementById('actionConfirmModal').style.display = 'flex';
      const confirmBtn = document.getElementById('confirmActionBtn');
      // remove previous handler
      confirmBtn.onclick = null;
      confirmBtn.onclick = () => {
        try { onConfirm && onConfirm(); } catch(e) { console.warn('confirm callback error', e); }
        closeActionConfirm();
      };
    }

    function closeActionConfirm() {
      document.getElementById('actionConfirmModal').style.display = 'none';
    }

    // Mafia coordination removed: mafia_final is handled by a single chooser server-side.

    async function checkGamePhaseForActions() {
      try {
        const resp = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/game-state`, { cache: 'no-store' });
        const gs = await resp.json();
        if (!gs) return;

        // If interactive mode is disabled for this room, do not show night-step indicators or prompt for actions
        try {
          if (gs.interactive_mode === false) {
            try { const stepEl = document.getElementById('nightStepIndicator'); if (stepEl) stepEl.textContent = ''; } catch(e) {}
            return;
          }
        } catch(e) { /* ignore */ }
        // Show current night step indicator
        try {
          const stepEl = document.getElementById('nightStepIndicator');
          if (gs.phase === 'night' && gs.current_night_step) {
            stepEl.textContent = 'Night step: ' + (gs.current_night_step.name || '(unknown)');
          } else {
            stepEl.textContent = '';
          }
        } catch(e) {}

  // Fetch players payload as well (we may fall back to its current_night_step)
  let pdata = null;
  try {
    const alivePlayersResp = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/players`, { cache: 'no-store' });
    pdata = await alivePlayersResp.json();
  } catch (e) {
    pdata = null;
  }

  // If phase changed to night (entered) or the night_step changed, and player has an actionable role for that step, prompt
  const combinedStep = gs.current_night_step || (pdata && pdata.current_night_step) || null;
  const stepChanged = (gs.phase === 'night' && lastKnownPhase !== 'night') || (gs.phase === 'night' && combinedStep && combinedStep.index !== lastKnownNightIndex);
        if (gs.phase === 'night') {
          // update mafia panel visibility and contents for mafia players
          // mafia coordination UI removed; however mafias still see visible teammates via visible_roles

          // determine player's role from DOM
          const role = document.getElementById('roleBadge').textContent || '';
          const low = role.toLowerCase();
          const alive = (pdata && pdata.players) ? pdata.players.filter(p => !(pdata.eliminated_players||[]).includes(p)) : [];
          // determine what actions this player may perform for the current night step
          pendingActionType = null;
          const step = combinedStep || gs.current_night_step;
          if (step && step.actions && step.actions.length) {
            const acts = step.actions;
            // map role keywords to action types and only allow if included in acts
            const roleActionMap = [
              {check: ['doctor','medic'], action: 'doctor_save'},
              {check: ['sheriff'], action: 'sheriff_mute'},
              {check: ['cop','detective'], action: 'cop_check'},
              {check: ['vigilante'], action: 'vigilante_kill'},
              {check: ['bodyguard','guard'], action: 'bodyguard_save'},
              {check: ['framer'], action: 'framer_pick'},
              // mafia finalize: only the designated chooser should be allowed to perform mafia_final
              {check: ['godfather','framer','mafia'], action: 'mafia_final'}
            ];

            for (const m of roleActionMap) {
              for (const kw of m.check) {
                if (low.includes(kw)) {
                  if (acts.includes(m.action)) {
                    // For mafia_final, verify chooser if server indicates one
                    if (m.action === 'mafia_final') {
                      // ask server whether this player is allowed to finalize (mafia_final_chooser)
                      try {
                        const gsChooser = gs.mafia_final_chooser;
                        if (gsChooser && gsChooser !== PLAYER_NAME) {
                          // not the chooser, skip
                          continue;
                        }
                        // if no chooser specified, allow mafias by default (server will double-check)
                      } catch(e) { /* ignore */ }
                    }
                    pendingActionType = m.action;
                    break;
                  }
                }
              }
              if (pendingActionType) break;
            }
          }

          // show modal when the step has changed OR modal is currently hidden (in case client missed change)
          // but do not re-show if we already submitted the same action for this step
          const alreadySubmittedHere = lastActionSubmitted && lastActionSubmitted.step != null && lastActionSubmitted.step === (step ? step.index : null) && lastActionSubmitted.action === pendingActionType;
          // If server reports this step already completed, don't prompt (helps avoid re-prompt when server moved on)
          const serverStepCompleted = (pdata && pdata.current_night_step_completed) || (gs && gs.current_night_step_completed);
          if (pendingActionType && !alreadySubmittedHere && !serverStepCompleted && (stepChanged || document.getElementById('nightModal').style.display === 'none')) {
            // Acquire modal reference early and atomically mark it opened to avoid races
            const modal = document.getElementById('nightModal');
            try {
              if (modal && modal.dataset && modal.dataset.opened === '1') {
                // already opened by a concurrent callback; mark prompt in progress and skip
                promptInProgress = true;
              } else {
                // mark opened immediately (atomic with respect to this JS execution block)
                if (modal && modal.dataset) modal.dataset.opened = '1';
                promptInProgress = true;
                try { lastShownStepIndex = step ? step.index : null; } catch(e) { lastShownStepIndex = null; }

                // populate clickable target tiles (sorted)
                const targetsEl = document.getElementById('nightTargets');
                targetsEl.innerHTML = '';
                const sorted = alive.slice().sort((a,b)=> a.localeCompare(b));
                for (const p of sorted) {
                  const tile = document.createElement('div');
                  tile.className = 'target-tile';
                  // mark eliminated players as disabled
                  const isElim = (pdata.eliminated_players||[]).includes(p);
                  if (!isElim) tile.classList.add('clickable'); else tile.classList.add('disabled');

                  const nameEl = document.createElement('div');
                  nameEl.className = 'player-name';
                  nameEl.textContent = p;
                  tile.appendChild(nameEl);

                  const actionsRow = document.createElement('div');
                  actionsRow.className = 'tile-actions';

                  // create action buttons depending on pendingActionType
                  function makeBtn(text, cls, onClick) {
                    const b = document.createElement('button');
                    b.className = 'btn';
                    b.style.padding = '0.45rem 0.6rem';
                    b.style.fontSize = '0.9rem';
                    b.style.borderRadius = '8px';
                    b.style.cursor = 'pointer';
                    b.textContent = text;
                    if (cls === 'kill') { b.style.background = '#dc2626'; b.style.color = 'white'; }
                    else if (cls === 'save') { b.style.background = '#059669'; b.style.color = 'white'; }
                    else if (cls === 'check') { b.style.background = '#2563eb'; b.style.color = 'white'; }
                    b.onclick = onClick;
                    return b;
                  }

                  const destructive = (pendingActionType === 'mafia_final' || pendingActionType === 'vigilante_kill' || pendingActionType === 'framer_pick');
                  if (pendingActionType === 'mafia_final' || pendingActionType === 'vigilante_kill') {
                    // destructive: confirm first
                    actionsRow.appendChild(makeBtn('Kill', 'kill', () => {
                      if (isElim) return; openActionConfirm(p, pendingActionType, () => submitNightActionTo(p, pendingActionType));
                    }));
                  } else if (pendingActionType === 'doctor_save' || pendingActionType === 'bodyguard_save') {
                    actionsRow.appendChild(makeBtn('Save', 'save', () => { if (isElim) return; submitNightActionTo(p, pendingActionType); }));
                  } else if (pendingActionType === 'cop_check') {
                    actionsRow.appendChild(makeBtn('Check', 'check', () => { if (isElim) return; submitNightActionTo(p, pendingActionType); }));
                  } else if (pendingActionType === 'sheriff_mute') {
                    actionsRow.appendChild(makeBtn('Mute', 'check', () => { if (isElim) return; submitNightActionTo(p, pendingActionType); }));
                  } else if (pendingActionType === 'framer_pick') {
                    actionsRow.appendChild(makeBtn('Frame', 'kill', () => { if (isElim) return; openActionConfirm(p, pendingActionType, () => submitNightActionTo(p, pendingActionType)); }));
                  } else {
                    // generic action button
                    actionsRow.appendChild(makeBtn('Select', 'check', () => { if (isElim) return; submitNightActionTo(p, pendingActionType); }));
                  }

                  tile.appendChild(actionsRow);
                  targetsEl.appendChild(tile);
                }

                // show appropriate title
                const title = document.getElementById('nightModalTitle');
                title.textContent = pendingActionType.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
                try { modal.style.display = 'flex'; } catch(e) {}
              }
            } catch (e) {
              // fallback to simple display if dataset unsupported
              try { document.getElementById('nightModal').style.display = 'flex'; } catch(e2) {}
              try { lastShownStepIndex = step ? step.index : null; } catch(e3) { lastShownStepIndex = null; }
              promptInProgress = true;
            }
          }
        }
  // track last seen night phase and night_step index to detect changes and avoid duplicate prompts
  // If the night step advanced since we last saw it, clear the lastActionSubmitted so roles can act again
  const prevNightIndex = lastKnownNightIndex;
  lastKnownPhase = gs.phase;
  lastKnownNightIndex = gs.current_night_step ? gs.current_night_step.index : null;
  if (prevNightIndex != null && lastKnownNightIndex != null && prevNightIndex !== lastKnownNightIndex) {
    lastActionSubmitted = null;
    lastShownStepIndex = null;
  }
      } catch (e) {
        // ignore
      }
    }

    // Poll game-state for night-phase actions every 2.5s
    setInterval(checkGamePhaseForActions, 2500);

    // Role avatar overlay: show once per session when role assigned
    function maybeShowRoleAvatar() {
      try {
        // Only show when the user explicitly clicked View My Role (thanks.html sets this flag)
        let shouldShow = false;
        try { shouldShow = sessionStorage.getItem('showRoleAvatarOnce') === '1'; } catch(e) { shouldShow = false; }
        if (!shouldShow) return;
        // remove the one-time flag to avoid repeated shows
        try { sessionStorage.removeItem('showRoleAvatarOnce'); } catch(e) {}

        const roleEl = document.getElementById('roleBadge');
        if (!roleEl) return;
        const roleText = (roleEl.textContent || '').trim();
        if (!roleText) return; // no role assigned yet

        const overlay = document.getElementById('roleAvatarOverlay');
        const card = document.getElementById('roleAvatarCard');
        const nameEl = document.getElementById('roleAvatarName');
        const roleNameEl = document.getElementById('roleAvatarRole');
        const imgEl = document.getElementById('roleAvatarImg');
        if (!overlay || !card || !imgEl || !nameEl || !roleNameEl) return;

        // load user images as before
        const lookup = (roleText || '').toLowerCase().replace(/\s+/g,'_');
        const candidates = [
          `/static/mafia_role_avatars/${lookup}.png`,
          `/static/mafia_role_avatars/${lookup}.webp`,
          `/static/mafia_role_avatars/${lookup}.jpg`,
          `/static/mafia_role_avatars/${lookup}.svg`
        ];
        const fallback = '/static/mafia_role_avatars/default.svg';
        let found = false;
        const tryNext = (i) => {
          if (i >= candidates.length) { imgEl.src = fallback; return; }
          const url = candidates[i];
          const probe = new Image();
          probe.onload = () => { imgEl.src = url; found = true; };
          probe.onerror = () => { if (!found) tryNext(i+1); };
          probe.src = url;
        };
        tryNext(0);

        nameEl.textContent = PLAYER_NAME;
        roleNameEl.textContent = roleText;

        // prepare fade-in (slower) and scale pop; center modal-style
        overlay.style.display = 'flex';
        overlay.style.opacity = '0';
        // slower fade on the backdrop
        overlay.style.transition = 'opacity 900ms ease';
        card.style.transform = 'scale(0.92)';
        // slower, smoother pop for the card
        card.style.transition = 'transform 900ms cubic-bezier(.2,.9,.2,1), opacity 900ms ease';
        requestAnimationFrame(() => {
          overlay.style.opacity = '1';
          card.style.transform = 'scale(1)';
        });

        // fade out after a longer visible period (3.2s visible)
        setTimeout(() => {
          overlay.style.opacity = '0';
          card.style.transform = 'scale(0.96)';
          // hide after transition ends
          setTimeout(() => { try { overlay.style.display = 'none'; } catch(e) {} }, 980);
        }, 3200);

      } catch (e) { console.warn('maybeShowRoleAvatar failed', e); }
    }

    // attempt to show avatar on first load if the session flag is present
    try { maybeShowRoleAvatar(); } catch(e) {}

    // Init site mute toggle (player)
    (function(){
      try {
        const btn = document.getElementById('siteMuteBtn');
        const iconWave = document.getElementById('siteMuteWave');
        if (!btn) return;
        const setMutedState = (muted) => {
          try { btn.setAttribute('aria-pressed', muted ? 'true' : 'false'); } catch(e) {}
          try { btn.title = muted ? 'Unmute site' : 'Mute site'; } catch(e) {}
          if (iconWave) iconWave.style.display = muted ? 'none' : '';
        };
        let initialMuted = false;
        try { initialMuted = localStorage.getItem('siteMuted') === '1'; } catch(e) {}
        setMutedState(initialMuted);
        btn.addEventListener('click', () => {
          try {
            const currently = (localStorage.getItem('siteMuted') === '1');
            const next = !currently;
            localStorage.setItem('siteMuted', next ? '1' : '0');
            setMutedState(next);
          } catch(e) { console.warn('site mute toggle failed', e); }
        });
      } catch(e) { console.warn('site mute init failed', e); }
    })();
  </script>
  </body>
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', function() {
        navigator.serviceWorker.register('/static/sw.js').catch(function(err){ console.warn('SW registration failed:', err); });
      });
    }
  </script>
  </html>