<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Your Role - Mafia Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="manifest" href="/static/manifest.json">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Mafia Game">
  <link rel="apple-touch-icon" href="/static/mafia_bg_pic.jpg">
  <style>
    body { 
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; 
      padding: 2rem; 
      background: #0f172a; 
      color: #e2e8f0; 
      min-height: 100vh;
      margin: 0;
    }
    .card { 
      max-width: 520px; 
      margin: 5vh auto; 
      background: #1e293b; 
      padding: 2rem; 
      border-radius: 12px; 
      box-shadow: 0 10px 30px rgba(0,0,0,0.3); 
      border: 1px solid #334155;
      position: relative;
    }
    .card.eliminated {
      border-color: #dc2626;
      background: #1a1a1a;
    }
    .status-indicator {
      position: absolute;
      top: 1rem;
      right: 1rem;
      padding: 0.5rem 1rem;
      border-radius: 6px;
      font-weight: bold;
      font-size: 0.9rem;
    }
    .status-alive {
      background: #059669;
      color: white;
    }
    .status-eliminated {
      background: #dc2626;
      color: white;
    }
    h1 { 
      margin-top: 0; 
      font-size: 1.6rem; 
      color: #f1f5f9;
      padding-right: 6rem;
    }
    h1.eliminated {
      color: #fca5a5;
      text-decoration: line-through;
    }
    .role-badge { 
      background: #fbbf24; 
      color: #92400e; 
      padding: 0.75rem 1.5rem; 
      border-radius: 8px; 
      font-weight: bold; 
      font-size: 1.2rem; 
      margin: 1rem 0; 
      text-align: center;
    }
    .role-badge.eliminated {
      background: #dc2626;
      color: white;
    }
    .warning { 
      background: #451a03; 
      color: #fbbf24; 
      padding: 1rem; 
      border-radius: 8px; 
      margin: 1rem 0; 
      border: 1px solid #92400e;
    }
    .description { 
      background: #374151; 
      padding: 1rem; 
      border-radius: 8px; 
      margin: 1rem 0; 
      color: #f1f5f9;
    }
    .description.eliminated {
      background: #4c1d1d;
      color: #fca5a5;
    }
    .button-group { 
      margin-top: 1.5rem; 
    }
    .btn { 
      padding: 0.8rem 1.5rem; 
      font-size: 1rem; 
      border: none; 
      border-radius: 8px; 
      cursor: pointer; 
      margin-right: 0.5rem; 
      margin-bottom: 0.5rem;
      font-weight: 600;
      transition: all 0.2s ease;
    }
    .btn-primary { 
      background: #2563eb; 
      color: white; 
    }
    .btn-primary:hover { 
      background: #1e40af; 
    }
    .btn-danger { 
      background: #dc2626; 
      color: white; 
    }
    .btn-danger:hover { 
      background: #b91c1c; 
    }
    .last-updated {
      font-size: 0.8rem;
      color: #94a3b8;
      margin-top: 1rem;
      text-align: center;
    }
    .footer { 
      text-align: center; 
      margin-top: 2rem; 
      color: #94a3b8; 
      font-size: 0.9rem; 
    }
    
    /* Elimination overlay */
    .elimination-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    .elimination-message {
      background: #1e293b;
      padding: 3rem;
      border-radius: 12px;
      text-align: center;
      border: 2px solid #dc2626;
      max-width: 400px;
    }
    .elimination-title {
      font-size: 4rem;
      margin-bottom: 1rem;
    }
    .elimination-text {
      font-size: 1.5rem;
      color: #fca5a5;
      margin-bottom: 1rem;
    }
    .elimination-status {
      background: #dc2626;
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 6px;
      font-weight: bold;
      display: inline-block;
    }
    
    /* Eliminated styling */
    .eliminated {
      opacity: 0.7;
    }
    /* Faction badge styles */
    .faction-badge {
      display: inline-block;
      padding: 0.25rem 0.6rem;
      border-radius: 8px;
      font-size: 0.9rem;
      font-weight: 700;
      color: white;
      margin-left: 0.6rem;
      border: 1px solid rgba(255,255,255,0.03);
    }
    .faction-mafia { background: #b91c1c; }
    .faction-villagers { background: #059669; }
    .faction-neutral { background: #6b7280; }
    .faction-unknown { background: #374151; color: #f1f5f9; }
    /* Unified faction color on player screen */
    .faction-unified { background: #2563eb; }
    /* Night target tile styles */
    .target-tile {
      background: #071020;
      border: 1px solid rgba(255,255,255,0.04);
      border-radius: 8px;
      padding: 0.6rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      align-items: stretch;
      transition: transform 120ms ease, box-shadow 120ms ease, opacity 160ms ease;
    }
    .target-tile.clickable { cursor: pointer; }
    .target-tile.clickable:hover { transform: translateY(-4px); box-shadow: 0 8px 26px rgba(2,6,23,0.6); }
    .target-tile.disabled { opacity: 0.55; cursor: not-allowed; }
    .target-tile .player-name { font-weight:700; }
    .target-tile .tile-actions { display:flex; gap:0.5rem; }
    .target-tile .checkmark {
      position: relative;
    }
    .tile-checkmark-badge {
      position: absolute;
      right: 6px;
      top: 6px;
      background: #10b981;
      color: white;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      box-shadow: 0 4px 14px rgba(16,185,129,0.16);
    }
    /* Suicide modal choice styles */
    .suicide-choice {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      padding: 0.6rem 0.75rem;
      background: #071022;
      border: 1px solid rgba(255,255,255,0.04);
      border-radius: 10px;
      cursor: pointer;
      transition: transform 120ms ease, box-shadow 120ms ease, background 120ms ease, border-color 120ms ease;
      color: #e2e8f0;
      font-weight: 700;
    }
    .suicide-choice:hover { transform: translateY(-3px); box-shadow: 0 8px 24px rgba(2,6,23,0.6); }
    .suicide-choice.disabled { opacity: 0.5; cursor: not-allowed; transform: none; box-shadow: none; }
    .suicide-choice .name { flex: 1; text-align: left; }
    .suicide-choice .check { width: 28px; height: 28px; border-radius: 50%; display: inline-flex; align-items: center; justify-content: center; font-size: 14px; }
    .suicide-choice .check.hidden { visibility: hidden; }
    .suicide-choice.selected { background: linear-gradient(90deg,#7c3aed,#2563eb); border-color: rgba(124,58,237,0.6); color: white; }
    .suicide-choice.selected .check { background: rgba(255,255,255,0.12); color: #fff; box-shadow: 0 6px 18px rgba(37,99,235,0.18); }
  </style>
</head>
<body>
  <div class="card" id="gameCard">
    <div class="status-indicator status-alive" id="statusIndicator">ALIVE</div>
    
    <h1 id="playerName">Welcome, {{ name | e }}!</h1>
    
    <div style="display:flex; align-items:center; gap:0.75rem;">
      <div class="role-badge" id="roleBadge">{{ role | e }}</div>
      {% if faction %}
        {# Show a unified faction badge color on the player role screen for consistency #}
        <span class="faction-badge faction-unified">{{ faction | e }}</span>
      {% endif %}
    </div>
    
    <div class="warning" id="warningMessage">
      ü§´ Keep your role secret! Don't let other players see this screen.
    </div>
    
    <div class="description" id="roleDescription">
      {{ description | e }}
    </div>

    <!-- Mafia coordination removed: mafia_final is handled by a single chooser (godfather/framer/random mafia)
         UI will prompt the designated chooser to submit mafia_final when appropriate. -->

    <!-- Visible teammates (e.g., mafias see other mafias) -->
    <div id="visibleTeammatesSection" style="display:none; margin-top:1rem;">
      <div class="roles-header">üïµÔ∏è‚Äç‚ôÇÔ∏è Teammates you can see</div>
      <div id="visibleTeammatesList" style="display:flex; flex-direction:column; gap:0.5rem;"></div>
    </div>
    
    <div class="button-group">
  <!-- Show/Hide role toggle -->
      <button id="toggleRoleBtn" class="btn btn-primary" onclick="toggleRoleVisibility(); return false;">Hide Role</button>
      
      <form method="post" action="{{ url_for('leave') }}" style="display: inline;">
        <input type="hidden" name="player_name" value="{{ name }}">
        <button type="submit" class="btn btn-danger" onclick="return confirm('Are you sure you want to leave the game?')">Leave Game</button>
      </form>
    </div>
    
    <div class="last-updated" id="lastUpdated">Last checked: ‚Äî</div>
  </div>

  <!-- Winner banner for players -->
  <div id="winnerBannerPlayer" style="display:none; position:fixed; left:50%; transform:translateX(-50%); top:12px; z-index:1300; padding:0.8rem 1rem; border-radius:8px; font-weight:900; color:#fff; background:#111; box-shadow:0 8px 24px rgba(0,0,0,0.6);">
    <span id="winnerBannerText">Winner: ‚Äî</span>
  </div>

  <!-- Read-only Moderator Dashboard for players (no action buttons) -->
  <div class="card" style="max-width:900px; margin: 1.25rem auto;" id="playerModeratorDashboard">
    <h3 style="margin-top:0;">Game Status</h3>
    <div style="display:flex; gap:1rem; flex-wrap:wrap;">
      <div style="flex:1; min-width:160px;">
        <div class="small">Phase</div>
        <div style="font-weight:800; font-size:1.05rem;" id="pdPhase">‚Äî</div>
        <div class="small" style="margin-top:0.5rem;">Night step</div>
        <div style="font-weight:700;" id="pdNightStep">‚Äî</div>
      </div>
      <div style="flex:1; min-width:160px;">
        <div class="small">Last night killed</div>
        <div style="font-weight:700;" id="pdLastKilled">‚Äî</div>
        <div class="small" style="margin-top:0.5rem;">Last night muted</div>
        <div style="font-weight:700;" id="pdLastMuted">‚Äî</div>
      </div>
      <div style="flex:1; min-width:220px; display:flex; flex-direction:column; gap:0.5rem;">
        <div>
          <div class="small">Last night events</div>
          <div id="pdLastEvents" style="background:#071024; padding:0.5rem; border-radius:8px; border:1px solid rgba(255,255,255,0.03); max-height:80px; overflow:auto;">‚Äî</div>
        </div>
        <div>
          <div class="small">Voting</div>
          <div id="votingDashboard" style="background:#071024; padding:0.5rem; border-radius:8px; border:1px solid rgba(255,255,255,0.03); max-height:160px; overflow:auto; display:none;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:0.5rem;">
              <div style="font-weight:700;">Status: <span id="vdVotingStatus">‚Äî</span></div>
              <div style="font-size:0.9rem; color:#94a3b8;">Current: <span id="vdCurrentVoter">‚Äî</span></div>
            </div>
            <div style="margin-bottom:0.5rem;">
              <div style="font-size:0.85rem; color:#94a3b8; margin-bottom:0.25rem;">Tally</div>
              <div id="vdTally" style="display:flex; gap:0.5rem; flex-wrap:wrap;">‚Äî</div>
            </div>
            <div>
              <div style="font-size:0.85rem; color:#94a3b8; margin-bottom:0.25rem;">Vote Log</div>
              <div id="vdVoteLog" style="max-height:62px; overflow:auto; font-size:0.9rem;">‚Äî</div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div style="position:fixed; left:1rem; bottom:1rem; color:#94a3b8; font-size:0.9rem;" id="nightStepIndicator"> </div>

  <!-- Night action modal: replaced select with clickable player tiles -->
  <div id="nightModal" style="display:none; position:fixed; left:0; top:0; width:100%; height:100%; background:rgba(0,0,0,0.6); align-items:center; justify-content:center; z-index:1200;">
    <div style="background:#0b1220; padding:1rem 1.25rem; border-radius:10px; width:640px; max-width:95%; border:1px solid rgba(255,255,255,0.04);">
      <h3 id="nightModalTitle" style="margin:0 0 0.5rem 0; color:#f1f5f9;">Night Action</h3>
      <div style="margin-bottom:0.5rem;">
        <label class="small">Choose target</label>
        <div id="nightTargets" style="display:grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap:8px; margin-top:0.5rem; max-height:360px; overflow:auto; padding-right:6px;"></div>
      </div>
      <div style="display:flex; gap:0.5rem; justify-content:flex-end;">
        <button class="btn" onclick="closeNightModal()">Close</button>
        <!-- backup submit button (hidden) kept for compatibility with older flows -->
        <button class="btn btn-primary" id="nightSubmitBtn" style="display:none;" onclick="submitNightAction()">Submit</button>
      </div>
    </div>
  </div>

  <!-- Elimination overlay -->
  <div class="elimination-overlay" id="eliminationOverlay">
    <div class="elimination-message">
      <div class="elimination-title">üíÄ</div>
      <div class="elimination-text">You have been eliminated!</div>
      <div class="elimination-status">ELIMINATED</div>
      <p style="color: #94a3b8; margin-top: 2rem;">
        You can continue to watch the game, but you can no longer participate.
      </p>
      <button class="btn btn-primary" onclick="window.location.href='/watch/' + encodeURIComponent(ROOM_NAME)" style="margin-top: 1rem;">
        Continue Watching
      </button>
    </div>
  </div>

  <!-- Suicide bomber prompt modal (shown only to the bomber if lynched) -->
  <div id="suicideModal" style="display:none; position:fixed; left:0; top:0; width:100%; height:100%; background:rgba(0,0,0,0.6); align-items:center; justify-content:center; z-index:1250;">
    <div style="background:#0b1220; padding:1rem 1.25rem; border-radius:10px; width:420px; border:1px solid rgba(255,255,255,0.04);">
      <h3 style="margin:0 0 0.5rem 0; color:#f1f5f9;">Final Act ‚Äî Choose a Target</h3>
      <div style="margin-bottom:0.5rem; color:#cbd5e1;">You have been lynched and your role allows a final act. Choose one player to eliminate with you.</div>
      <div id="suicideChoices" style="display:flex; flex-direction:column; gap:0.5rem; max-height:240px; overflow:auto; margin-top:0.5rem;"></div>
      <div style="display:flex; gap:0.5rem; justify-content:flex-end; margin-top:0.75rem;">
        <button class="btn" onclick="closeSuicideModal()">Skip</button>
        <button class="btn btn-danger" id="suicideSubmitBtn" onclick="submitSuicideChoice()">Submit</button>
      </div>
    </div>
  </div>

  <!-- Voting modal shown to the current voter when a voting session is active -->
  <div id="votingModal" style="display:none; position:fixed; left:0; top:0; width:100%; height:100%; background:rgba(0,0,0,0.6); align-items:center; justify-content:center; z-index:1260;">
    <div style="background:#0b1220; padding:1rem 1.25rem; border-radius:10px; width:520px; border:1px solid rgba(255,255,255,0.04);">
      <h3 style="margin:0 0 0.5rem 0; color:#f1f5f9;">Voting ‚Äî It's your turn</h3>
      <div style="margin-bottom:0.5rem; color:#cbd5e1;">Select a player to vote for lynching. The host and other players can watch who is voting and the running vote log.</div>
      <div id="votingChoices" style="display:flex; flex-direction:column; gap:0.5rem; max-height:320px; overflow:auto; margin-top:0.5rem;"></div>
      <div style="display:flex; gap:0.5rem; justify-content:flex-end; margin-top:0.75rem;">
        <button class="btn" onclick="closeVotingModal()">Skip</button>
      </div>
    </div>
  </div>

  <!-- Action confirmation modal -->
  <div id="actionConfirmModal" style="display:none; position:fixed; left:0; top:0; width:100%; height:100%; background:rgba(0,0,0,0.6); align-items:center; justify-content:center; z-index:1220;">
    <div style="background:#0b1220; padding:1rem 1.25rem; border-radius:10px; width:420px; border:1px solid rgba(255,255,255,0.04);">
      <h3 id="actionConfirmTitle" style="margin:0 0 0.5rem 0; color:#f1f5f9;">Confirm Action</h3>
      <div id="actionConfirmText" style="margin-bottom:0.75rem; color:#cbd5e1;"></div>
      <div style="display:flex; gap:0.5rem; justify-content:flex-end;">
        <button class="btn" onclick="closeActionConfirm()">Cancel</button>
        <button class="btn btn-danger" id="confirmActionBtn">Confirm</button>
      </div>
    </div>
  </div>

  <!-- Toast notification for brief messages before redirects -->
  <div id="toast" style="display:none; position: fixed; left: 50%; transform: translateX(-50%); bottom: 12vh; background: rgba(0,0,0,0.7); color: #fff; padding: 0.8rem 1.2rem; border-radius: 8px; font-weight: 700; box-shadow: 0 6px 20px rgba(0,0,0,0.5); z-index: 1100;">
    <span id="toastMessage">Message</span>
  </div>

  <div class="footer">
    Created by Scissors. Powered by Sunisha and Diet Coke
  </div>

  <script>
    const PLAYER_NAME = '{{ name | e }}';
    const ROOM_NAME = '{{ room_name | e }}';
    
  let isEliminated = false;
  let hasShownEliminationMessage = false;
  // Persist last-known voting snapshot on the client so the voting dashboard
  // remains visible until the next Day phase begins (server-driven).
  let persistentVotingSnapshot = null;
  let lastSeenPhaseForVoting = null;

    function escapeHtml(str) {
      const p = document.createElement('p');
      p.innerText = str;
      return p.innerHTML;
    }

    function showToast(msg, ms = 1200) {
      try {
        const toast = document.getElementById('toast');
        const msgEl = document.getElementById('toastMessage');
        msgEl.textContent = msg;
        toast.style.display = 'block';
        // fade in
        toast.style.opacity = 0;
        toast.style.transition = 'opacity 160ms ease';
        requestAnimationFrame(() => { toast.style.opacity = 1; });
        setTimeout(() => {
          // fade out
          toast.style.opacity = 0;
          setTimeout(() => { toast.style.display = 'none'; }, 220);
        }, ms);
      } catch (e) { console.warn('Toast failed', e); }
    }

    function showEliminationOverlay() {
      if (!hasShownEliminationMessage) {
        document.getElementById('eliminationOverlay').style.display = 'flex';
        hasShownEliminationMessage = true;
      }
    }

    function hideEliminationOverlay() {
      document.getElementById('eliminationOverlay').style.display = 'none';
    }

    // Role visibility toggle
    let roleVisible = true;
    function toggleRoleVisibility() {
      try {
        roleVisible = !roleVisible;
        const roleBadge = document.getElementById('roleBadge');
        const roleDescription = document.getElementById('roleDescription');
        const toggleBtn = document.getElementById('toggleRoleBtn');
        const warningMessage = document.getElementById('warningMessage');
        const teammatesSection = document.getElementById('visibleTeammatesSection');
        const teammatesList = document.getElementById('visibleTeammatesList');
        // faction badges shown on this screen (e.g., next to roleBadge and teammates)
        const factionBadges = document.querySelectorAll('.faction-unified');
        if (roleVisible) {
          if (roleBadge) roleBadge.style.display = 'block';
          if (roleDescription) roleDescription.style.display = 'block';
          if (warningMessage) warningMessage.style.display = 'block';
          // only show teammates section if it actually has items
          if (teammatesSection && teammatesList && teammatesList.children && teammatesList.children.length) {
            teammatesSection.style.display = 'block';
          }
          // show faction badges (restore default display)
          if (factionBadges && factionBadges.length) {
            factionBadges.forEach(b => { b.style.display = ''; });
          }
          if (toggleBtn) toggleBtn.textContent = 'Hide Role';
        } else {
          if (roleBadge) roleBadge.style.display = 'none';
          if (roleDescription) roleDescription.style.display = 'none';
          if (warningMessage) warningMessage.style.display = 'none';
          // hide the teammates section when the role is hidden (useful for mafia players)
          if (teammatesSection) teammatesSection.style.display = 'none';
          // hide faction badges when role hidden
          if (factionBadges && factionBadges.length) {
            factionBadges.forEach(b => { b.style.display = 'none'; });
          }
          if (toggleBtn) toggleBtn.textContent = 'Show Role';
        }
      } catch (e) { console.warn('toggleRoleVisibility failed', e); }
    }

    function updateEliminationStatus(eliminated) {
      const gameCard = document.getElementById('gameCard');
      const playerName = document.getElementById('playerName');
      const roleBadge = document.getElementById('roleBadge');
      const roleDescription = document.getElementById('roleDescription');
      const statusIndicator = document.getElementById('statusIndicator');
      const warningMessage = document.getElementById('warningMessage');

      if (eliminated && !isEliminated) {
        // Player just got eliminated
        isEliminated = true;
        
        // Update visual elements
        gameCard.classList.add('eliminated');
        playerName.classList.add('eliminated');
        roleBadge.classList.add('eliminated');
        roleDescription.classList.add('eliminated');
        
        statusIndicator.textContent = 'ELIMINATED üíÄ';
        statusIndicator.className = 'status-indicator status-eliminated';
        
        warningMessage.innerHTML = 'üíÄ You have been eliminated from the game!';
        warningMessage.style.background = '#4c1d1d';
        warningMessage.style.color = '#f87171';
        warningMessage.style.borderColor = '#dc2626';
        
        // Show elimination overlay
        showEliminationOverlay();
        
      } else if (!eliminated && isEliminated) {
        // Player was revived (unlikely but possible)
        isEliminated = false;
        
        // Remove elimination styling
        gameCard.classList.remove('eliminated');
        playerName.classList.remove('eliminated');
        roleBadge.classList.remove('eliminated');
        roleDescription.classList.remove('eliminated');
        
        statusIndicator.textContent = 'ALIVE';
        statusIndicator.className = 'status-indicator status-alive';
        
        warningMessage.innerHTML = "ü§´ Keep your role secret! Don't let other players see this screen.";
        warningMessage.style.background = '#451a03';
        warningMessage.style.color = '#fbbf24';
        warningMessage.style.borderColor = '#92400e';
        
        hideEliminationOverlay();
      }
    }

    async function checkEliminationStatus() {
      try {
        const response = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/players`, {
          cache: 'no-store'
        });
        
        if (!response.ok) {
          throw new Error('Failed to fetch player status');
        }
        
        const data = await response.json();
  const eliminatedPlayers = data.eliminated_players || [];
        const isPlayerEliminated = eliminatedPlayers.includes(PLAYER_NAME);
        
        updateEliminationStatus(isPlayerEliminated);

        // If server indicates a pending suicide prompt for this player, render the modal choices
        try {
          const sp = data.suicide_prompt || { active: false };
          if (sp && sp.active) {
            // populate and show modal
            renderSuicideChoices(sp.choices || []);
            document.getElementById('suicideModal').style.display = 'flex';
          }
        } catch (e) { console.warn('suicide prompt render error', e); }

        // If the host has restarted the game, assignments may be cleared and game_started will be false.
        // In that case, redirect this player back to the waiting/thanks page so they see the lobby.
        const gameStarted = !!data.game_started;
        const assignments = data.assignments || {};
        const hasAssignment = Object.prototype.hasOwnProperty.call(assignments, PLAYER_NAME);
        if (!gameStarted || !hasAssignment) {
          // Show a brief toast so player understands what's happening, then redirect back to the lobby/waiting page
          showToast('Host restarted the game ‚Äî returning to lobby...', 1400);
          setTimeout(() => {
            window.location.replace(`/room/${encodeURIComponent(ROOM_NAME)}`);
          }, 1400);
          return;
        }
        
        // Update last checked time
        const now = new Date();
        document.getElementById('lastUpdated').textContent = 
          'Last checked: ' + now.toLocaleTimeString();

        // show winner banner if game over
        try {
          const gsResp = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/game-state`, { cache: 'no-store' });
          if (gsResp && gsResp.ok) {
            const gs = await gsResp.json();
            if (gs && gs.game_over) {
              const wb = document.getElementById('winnerBannerPlayer');
              const wbt = document.getElementById('winnerBannerText');
              if (wb && wbt) {
                wbt.textContent = 'Winner: ' + (gs.winner || '‚Äî');
                wb.style.display = 'block';
                if ((gs.winner || '').toLowerCase() === 'mafia') wb.style.background = 'linear-gradient(90deg,#7f1d1d,#b91c1c)';
                else if ((gs.winner || '').toLowerCase() === 'villagers') wb.style.background = 'linear-gradient(90deg,#064e3b,#059669)';
                else wb.style.background = '#111';
              }
            }
          }
        } catch (e) { /* non-fatal */ }

        // Populate read-only moderator dashboard from players response if available
        try {
          const pdPhase = document.getElementById('pdPhase');
          const pdNightStep = document.getElementById('pdNightStep');
          const pdLastKilled = document.getElementById('pdLastKilled');
          const pdLastMuted = document.getElementById('pdLastMuted');
          const pdLastEvents = document.getElementById('pdLastEvents');
          // If server indicates interactive_mode is false, hide phase/night info from players
          const interactive = (typeof data.interactive_mode === 'undefined') ? true : !!data.interactive_mode;
          if (!interactive) {
            // hide phase info
            if (pdPhase) pdPhase.textContent = '‚Äî';
            if (pdNightStep) pdNightStep.textContent = '‚Äî';
            if (pdLastKilled) pdLastKilled.textContent = '‚Äî';
            if (pdLastMuted) pdLastMuted.textContent = '‚Äî';
            if (pdLastEvents) pdLastEvents.textContent = '‚Äî';
          } else {
            if (pdPhase) pdPhase.textContent = data.phase || '‚Äî';
            if (pdNightStep) pdNightStep.textContent = data.current_night_step ? (data.current_night_step.name || '') + (data.current_night_step.index != null ? ` (step ${data.current_night_step.index})` : '') : '‚Äî';
            const killedList = (data.last_night_killed && data.last_night_killed.length) ? data.last_night_killed : (data.last_night_events && data.last_night_events.killed ? data.last_night_events.killed : []);
            const mutedVal = (data.last_night_muted !== undefined && data.last_night_muted !== null) ? data.last_night_muted : (data.last_night_events ? data.last_night_events.muted : null);
            if (pdLastKilled) pdLastKilled.textContent = (killedList && killedList.length) ? killedList.join(', ') : '‚Äî';
            if (pdLastMuted) pdLastMuted.textContent = (mutedVal) ? mutedVal : '‚Äî';
            if (pdLastEvents) {
              const parts = [];
              if (killedList && killedList.length) parts.push('<b>Killed:</b> ' + killedList.join(', '));
              if (mutedVal) parts.push('<b>Muted:</b> ' + mutedVal);
              pdLastEvents.innerHTML = parts.length ? parts.join('<br>') : '‚Äî';
            }
          }
        } catch (e) { /* ignore dashboard binding errors */ }
        // Voting UI: persistent voting dashboard (separate from last events)
        try {
          const voting = data.voting || null;
          const vd = document.getElementById('votingDashboard');
          const vdStatus = document.getElementById('vdVotingStatus');
          const vdCurrent = document.getElementById('vdCurrentVoter');
          const vdTally = document.getElementById('vdTally');
          const vdLog = document.getElementById('vdVoteLog');

          function renderTally(tally) {
            if (!vdTally) return;
            vdTally.innerHTML = '';
            if (!tally || Object.keys(tally).length === 0) {
              vdTally.textContent = '‚Äî';
              return;
            }
            const entries = Object.entries(tally).sort((a,b)=> b[1]-a[1]);
            for (const [name, count] of entries) {
              const el = document.createElement('div');
              el.style.padding = '0.25rem 0.5rem';
              el.style.background = '#0b1220';
              el.style.border = '1px solid rgba(255,255,255,0.03)';
              el.style.borderRadius = '6px';
              el.style.fontWeight = '700';
              el.textContent = `${name}: ${count}`;
              vdTally.appendChild(el);
            }
          }

          function renderLog(votes_log) {
            if (!vdLog) return;
            if (!votes_log || !votes_log.length) {
              vdLog.textContent = '‚Äî';
              return;
            }
            vdLog.innerHTML = '';
            for (const l of votes_log.slice(-20)) {
              const el = document.createElement('div');
              el.style.padding = '2px 0';
              el.textContent = `${l.voter} ‚Üí ${l.choice}`;
              vdLog.appendChild(el);
            }
          }

          // Update persistent snapshot and render. The client persists the last-known voting snapshot
          // until the server announces the Day phase (per requirement).
          if (voting) {
            // If server explicitly indicates a reset, clear the persistent snapshot immediately.
            if (voting.reset) {
              persistentVotingSnapshot = null;
              if (vd) vd.style.display = 'none';
              if (vdStatus) vdStatus.textContent = '‚Äî';
              if (vdCurrent) vdCurrent.textContent = '‚Äî';
              if (vdTally) vdTally.textContent = '‚Äî';
              if (vdLog) vdLog.textContent = '‚Äî';
            } else {
              // Always refresh the persistent snapshot with any voting info we receive from server
              persistentVotingSnapshot = voting;
            }
          }

          // Only clear the persistent snapshot when we observe a full night->day transition.
          // This ensures the voting dashboard persists for the remainder of the day after voting ends.
          const phaseLower = data.phase ? data.phase.toLowerCase() : null;
          if (phaseLower === 'day' && lastSeenPhaseForVoting && lastSeenPhaseForVoting.toLowerCase() === 'night') {
            // We have seen a night since the last snapshot ‚Äî clear it now at start of the new day
            persistentVotingSnapshot = null;
            if (vd) vd.style.display = 'none';
            if (vdStatus) vdStatus.textContent = '‚Äî';
            if (vdCurrent) vdCurrent.textContent = '‚Äî';
            if (vdTally) vdTally.textContent = '‚Äî';
            if (vdLog) vdLog.textContent = '‚Äî';
          } else if (persistentVotingSnapshot) {
            // Render the last-known snapshot and keep it visible until Day phase arrives
            if (vd) vd.style.display = 'block';
            if (vdStatus) vdStatus.textContent = (persistentVotingSnapshot.active ? 'ACTIVE' : 'ENDED');
            if (vdCurrent) vdCurrent.textContent = persistentVotingSnapshot.current_voter || '‚Äî';
            renderTally(persistentVotingSnapshot.tally || {});
            renderLog(persistentVotingSnapshot.votes_log || []);

            // If it's this player's turn (snapshot may indicate current_voter), show voting modal
            if (persistentVotingSnapshot.current_voter === PLAYER_NAME && persistentVotingSnapshot.active) {
              const aliveChoices = data.players.filter(p => !(data.eliminated_players||[]).includes(p));
              renderVotingChoices(aliveChoices);
              try { document.getElementById('votingModal').style.display = 'flex'; } catch(e) {}
            }
          } else {
            // No snapshot and not Day ‚Äî keep dashboard hidden
            if (vd) vd.style.display = 'none';
          }

          // remember last seen phase for potential future logic
          lastSeenPhaseForVoting = data.phase || lastSeenPhaseForVoting;
        } catch (e) { console.warn('Voting dashboard update failed', e); }
        // Render visible teammates if provided (e.g., mafia members)
        try {
          const visible = data.visible_roles || [];
          const section = document.getElementById('visibleTeammatesSection');
          const list = document.getElementById('visibleTeammatesList');
          if (visible && visible.length && roleVisible) {
            section.style.display = 'block';
            list.innerHTML = '';
            visible.forEach(v => {
              const el = document.createElement('div');
              el.style.display = 'flex';
              el.style.justifyContent = 'space-between';
              el.style.alignItems = 'center';
              el.style.padding = '0.5rem';
              el.style.background = '#111827';
              el.style.borderRadius = '8px';
              el.innerHTML = `<strong>${escapeHtml(v.name)}</strong><span class="faction-badge faction-unified">${escapeHtml(v.role)}</span>`;
              list.appendChild(el);
            });
          } else {
            section.style.display = 'none';
            list.innerHTML = '';
          }
        } catch (e) { console.warn('Could not render visible teammates', e); }
        
      } catch (error) {
        console.error('Error checking elimination status:', error);
        document.getElementById('lastUpdated').textContent = 
          'Last checked: Error connecting to server';
      }
    }

    // Check elimination status immediately and then every 3 seconds
    checkEliminationStatus();
    setInterval(checkEliminationStatus, 3000);

    // Suicide modal helpers
    function renderSuicideChoices(choices) {
      const container = document.getElementById('suicideChoices');
      // remember previously selected choice (if any) so we can restore it after re-render
      const prevSelected = container && container.dataset && container.dataset.selected ? container.dataset.selected : '';
      container.innerHTML = '';
      // disable submit until a selection is made
      try { document.getElementById('suicideSubmitBtn').disabled = true; } catch(e) {}
      if (!choices || !choices.length) {
        const p = document.createElement('div'); p.textContent = 'No valid targets available.'; container.appendChild(p); return;
      }
      for (const c of choices) {
        const el = document.createElement('div');
        el.className = 'suicide-choice';
        el.tabIndex = 0;
        el.dataset.name = c;

        const name = document.createElement('div');
        name.className = 'name';
        name.textContent = c;

        const check = document.createElement('div');
        check.className = 'check hidden';
        check.innerHTML = '‚úì';

        el.appendChild(name);
        el.appendChild(check);

        // click and keyboard support
        const selectFn = () => {
          if (el.classList.contains('disabled')) return;
          // clear previous
          Array.from(container.querySelectorAll('.suicide-choice')).forEach(s => {
            s.classList.remove('selected');
            const ch = s.querySelector('.check'); if (ch) ch.classList.add('hidden');
          });
          el.classList.add('selected');
          const ch = el.querySelector('.check'); if (ch) ch.classList.remove('hidden');
          container.dataset.selected = c;
          try { document.getElementById('suicideSubmitBtn').disabled = false; } catch(e) {}
          // keep focus on the selected element so keyboard users see persistent highlight
          try { el.focus(); } catch(e) {}
        };

        el.addEventListener('click', selectFn);
        el.addEventListener('keydown', (ev) => { if (ev.key === 'Enter' || ev.key === ' ') { ev.preventDefault(); selectFn(); } });

        container.appendChild(el);
      }
      // restore previous selection if it still exists in the new choices
      try {
        if (prevSelected) {
          const restored = Array.from(container.querySelectorAll('.suicide-choice')).find(s => s.dataset && s.dataset.name === prevSelected);
          if (restored) {
            // simulate selection without re-triggering event handlers
            restored.classList.add('selected');
            const ch = restored.querySelector('.check'); if (ch) ch.classList.remove('hidden');
            container.dataset.selected = prevSelected;
            try { document.getElementById('suicideSubmitBtn').disabled = false; } catch(e) {}
            try { restored.focus(); } catch(e) {}
          }
        }
      } catch (e) { /* non-fatal */ }
    }

    function closeSuicideModal() {
      try { 
        const modal = document.getElementById('suicideModal');
        modal.style.display = 'none'; 
        // clear selection
        const container = document.getElementById('suicideChoices');
        if (container) { container.innerHTML = ''; container.dataset.selected = ''; }
        try { document.getElementById('suicideSubmitBtn').disabled = true; } catch(e) {}
      } catch (e) {}
    }

    async function submitSuicideChoice() {
      try {
        const container = document.getElementById('suicideChoices');
        const selected = container && container.dataset && container.dataset.selected ? container.dataset.selected : null;
        if (!selected) { alert('Select a player to eliminate with you'); return; }
        const form = new URLSearchParams();
        form.append('target', selected);
        const resp = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/suicide`, { method: 'POST', headers: {'Content-Type':'application/x-www-form-urlencoded'}, body: form.toString() });
        const d = await resp.json();
        if (d && d.success) {
          showToast('Final act submitted ‚Äî you have been eliminated', 1600);
          // after a short delay redirect to watch page (eliminated view)
          setTimeout(() => { window.location.replace(`/watch/${encodeURIComponent(ROOM_NAME)}`); }, 1600);
        } else {
          alert('Submission failed: ' + (d.error || 'unknown'));
        }
      } catch (e) {
        console.error('submitSuicideChoice error', e);
        alert('Error submitting final act');
      }
    }

    // Voting modal helpers
    function renderVotingChoices(choices) {
      const container = document.getElementById('votingChoices');
      container.innerHTML = '';
      if (!choices || !choices.length) {
        const p = document.createElement('div'); p.textContent = 'No players available to vote for.'; container.appendChild(p); return;
      }
      for (const c of choices) {
        const el = document.createElement('div');
        el.className = 'suicide-choice'; // reuse style for compact tiles
        el.tabIndex = 0;
        el.dataset.name = c;

        const name = document.createElement('div');
        name.className = 'name';
        name.textContent = c;

        const btn = document.createElement('button');
        btn.className = 'btn btn-danger';
        btn.textContent = 'Vote';
        btn.onclick = () => { if (confirm(`Confirm vote for ${c}?`)) submitVote(c); };

        el.appendChild(name);
        el.appendChild(btn);
        container.appendChild(el);
      }
    }

    function closeVotingModal() {
      try { document.getElementById('votingModal').style.display = 'none'; } catch(e) {}
    }

    async function submitVote(choice) {
      try {
        const form = new URLSearchParams();
        form.append('choice', choice);
        const resp = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/vote`, { method: 'POST', headers: {'Content-Type':'application/x-www-form-urlencoded'}, body: form.toString() });
        const d = await resp.json();
        if (d && d.success) {
          showToast('Vote submitted', 900);
          closeVotingModal();
          // refresh immediately so players and host see updated log/tally
          setTimeout(() => { checkEliminationStatus(); }, 250);
        } else {
          alert('Vote failed: ' + (d.error || 'unknown'));
        }
      } catch (e) {
        console.error('submitVote error', e);
        alert('Error submitting vote');
      }
    }

  // Night action handling
  let lastKnownPhase = null;
  let lastKnownNightIndex = null;
  let pendingActionType = null;
  // Remember the last action the client submitted (to avoid re-prompting for same step)
  let lastActionSubmitted = null; // { step: index, action: 'sheriff_mute' }
  // Step index that was shown when the modal was opened
  let lastShownStepIndex = null;
  // Prevent overlapping prompt renders
  let promptInProgress = false;

    function closeNightModal() {
      const modal = document.getElementById('nightModal');
      try { if (modal && modal.dataset) modal.dataset.opened = '0'; } catch(e) {}
      try { modal.style.display = 'none'; } catch(e) {}
      promptInProgress = false;
    }

    async function submitNightAction() {
      // Legacy single-submit fallback (kept for compatibility)
      const target = document.getElementById('nightTarget') ? (document.getElementById('nightTarget').value || '') : '';
      if (!pendingActionType) { alert('No action in progress'); return; }
      await submitNightActionTo(target, pendingActionType);
    }

    // Submit an action to the server for the given target and actionType.
    async function submitNightActionTo(target, actionType) {
      if (!actionType) { alert('No action type specified'); return; }
      try {
        const body = `action_type=${encodeURIComponent(actionType)}&target=${encodeURIComponent(target || '')}`;
        const resp = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/action`, { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded' }, body });
        const d = await resp.json();
          // fetch game-state and update read-only dashboard
          try {
            const gsResp = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/game-state`, { cache: 'no-store' });
            if (gsResp && gsResp.ok) {
              const gs = await gsResp.json();
              const pdPhase = document.getElementById('pdPhase');
              const pdNightStep = document.getElementById('pdNightStep');
              const pdLastKilled = document.getElementById('pdLastKilled');
              const pdLastMuted = document.getElementById('pdLastMuted');
              const pdLastEvents = document.getElementById('pdLastEvents');
              if (pdPhase) pdPhase.textContent = gs.phase || '‚Äî';
              if (pdNightStep) pdNightStep.textContent = gs.current_night_step ? (gs.current_night_step.name || '') + (gs.current_night_step.index != null ? ` (step ${gs.current_night_step.index})` : '') : '‚Äî';
              const killedList = (gs.last_night_killed && gs.last_night_killed.length) ? gs.last_night_killed : (gs.last_night_events && gs.last_night_events.killed ? gs.last_night_events.killed : []);
              const mutedVal = (gs.last_night_muted !== undefined && gs.last_night_muted !== null) ? gs.last_night_muted : (gs.last_night_events ? gs.last_night_events.muted : null);
              if (pdLastKilled) pdLastKilled.textContent = (killedList && killedList.length) ? killedList.join(', ') : '‚Äî';
              if (pdLastMuted) pdLastMuted.textContent = (mutedVal) ? mutedVal : '‚Äî';
              if (pdLastEvents) {
                const parts = [];
                const killedParts = (gs.last_night_killed && gs.last_night_killed.length) ? gs.last_night_killed : (gs.last_night_events && gs.last_night_events.killed ? gs.last_night_events.killed : []);
                const mutedPart = (gs.last_night_muted !== undefined && gs.last_night_muted !== null) ? gs.last_night_muted : (gs.last_night_events ? gs.last_night_events.muted : null);
                if (killedParts && killedParts.length) parts.push('<b>Killed:</b> ' + killedParts.join(', '));
                if (mutedPart) parts.push('<b>Muted:</b> ' + mutedPart);
                pdLastEvents.innerHTML = parts.length ? parts.join('<br>') : '‚Äî';
              }
            }
          } catch (e) {
            // ignore game-state fetch errors for player dashboard
          }
        if (d.success) {
          showToast('Action submitted', 1000);
          if (d.cop_result) {
            const r = d.cop_result;
            alert(`Investigation result:\n${r.checked} ‚Üí ${r.result}`);
          }
          // close modal and clear pending action
          closeNightModal();
          try { const modalEl = document.getElementById('nightModal'); if (modalEl && modalEl.dataset) modalEl.dataset.opened = '0'; } catch(e) {}
          // record submitted action so we don't re-prompt for the same step/action
          try { lastActionSubmitted = { step: (lastShownStepIndex != null ? lastShownStepIndex : null), action: actionType }; } catch(e) { lastActionSubmitted = { step: null, action: actionType }; }
          pendingActionType = null;
          // mark target tile acted and disable its buttons
          try {
            const targetsEl = document.getElementById('nightTargets');
            if (targetsEl) {
              const tiles = Array.from(targetsEl.querySelectorAll('.target-tile'));
              for (const t of tiles) {
                const n = t.querySelector('div') && t.querySelector('div').textContent && t.querySelector('div').textContent.trim();
                if (n === target) {
                  t.classList.add('disabled');
                  // add checkmark badge
                  if (!t.querySelector('.tile-checkmark-badge')) {
                    const cb = document.createElement('div'); cb.className = 'tile-checkmark-badge'; cb.textContent = '‚úì';
                    // position relative container
                    t.style.position = 'relative';
                    t.appendChild(cb);
                  }
                  // disable buttons inside
                  t.querySelectorAll('button').forEach(b => b.disabled = true);
                }
              }
            }
          } catch (e) { /* ignore UI update errors */ }
        } else {
          alert('Action failed: ' + (d.error || 'unknown'));
        }
      } catch (e) {
        console.error('submitNightActionTo error', e);
        alert('Error submitting action');
      }
    }

    function openActionConfirm(target, actionType, onConfirm) {
      const title = document.getElementById('actionConfirmTitle');
      const text = document.getElementById('actionConfirmText');
      title.textContent = 'Confirm ' + (actionType || '').replace(/_/g,' ').replace(/\b\w/g, c=>c.toUpperCase());
      text.textContent = `Are you sure you want to ${ (actionType||'').replace(/_/g,' ') } ${target || ''}? This cannot be undone.`;
      document.getElementById('actionConfirmModal').style.display = 'flex';
      const confirmBtn = document.getElementById('confirmActionBtn');
      // remove previous handler
      confirmBtn.onclick = null;
      confirmBtn.onclick = () => {
        try { onConfirm && onConfirm(); } catch(e) { console.warn('confirm callback error', e); }
        closeActionConfirm();
      };
    }

    function closeActionConfirm() {
      document.getElementById('actionConfirmModal').style.display = 'none';
    }

    // Mafia coordination removed: mafia_final is handled by a single chooser server-side.

    async function checkGamePhaseForActions() {
      try {
        const resp = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/game-state`, { cache: 'no-store' });
        const gs = await resp.json();
        if (!gs) return;

        // If interactive mode is disabled for this room, do not show night-step indicators or prompt for actions
        try {
          if (gs.interactive_mode === false) {
            try { const stepEl = document.getElementById('nightStepIndicator'); if (stepEl) stepEl.textContent = ''; } catch(e) {}
            return;
          }
        } catch(e) { /* ignore */ }
        // Show current night step indicator
        try {
          const stepEl = document.getElementById('nightStepIndicator');
          if (gs.phase === 'night' && gs.current_night_step) {
            stepEl.textContent = 'Night step: ' + (gs.current_night_step.name || '(unknown)');
          } else {
            stepEl.textContent = '';
          }
        } catch(e) {}

  // Fetch players payload as well (we may fall back to its current_night_step)
  let pdata = null;
  try {
    const alivePlayersResp = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/players`, { cache: 'no-store' });
    pdata = await alivePlayersResp.json();
  } catch (e) {
    pdata = null;
  }

  // If phase changed to night (entered) or the night_step changed, and player has an actionable role for that step, prompt
  const combinedStep = gs.current_night_step || (pdata && pdata.current_night_step) || null;
  const stepChanged = (gs.phase === 'night' && lastKnownPhase !== 'night') || (gs.phase === 'night' && combinedStep && combinedStep.index !== lastKnownNightIndex);
        if (gs.phase === 'night') {
          // update mafia panel visibility and contents for mafia players
          // mafia coordination UI removed; however mafias still see visible teammates via visible_roles

          // determine player's role from DOM
          const role = document.getElementById('roleBadge').textContent || '';
          const low = role.toLowerCase();
          const alive = (pdata && pdata.players) ? pdata.players.filter(p => !(pdata.eliminated_players||[]).includes(p)) : [];
          // determine what actions this player may perform for the current night step
          pendingActionType = null;
          const step = combinedStep || gs.current_night_step;
          if (step && step.actions && step.actions.length) {
            const acts = step.actions;
            // map role keywords to action types and only allow if included in acts
            const roleActionMap = [
              {check: ['doctor','medic'], action: 'doctor_save'},
              {check: ['sheriff'], action: 'sheriff_mute'},
              {check: ['cop','detective'], action: 'cop_check'},
              {check: ['vigilante'], action: 'vigilante_kill'},
              {check: ['bodyguard','guard'], action: 'bodyguard_save'},
              {check: ['framer'], action: 'framer_pick'},
              // mafia finalize: only the designated chooser should be allowed to perform mafia_final
              {check: ['godfather','framer','mafia'], action: 'mafia_final'}
            ];

            for (const m of roleActionMap) {
              for (const kw of m.check) {
                if (low.includes(kw)) {
                  if (acts.includes(m.action)) {
                    // For mafia_final, verify chooser if server indicates one
                    if (m.action === 'mafia_final') {
                      // ask server whether this player is allowed to finalize (mafia_final_chooser)
                      try {
                        const gsChooser = gs.mafia_final_chooser;
                        if (gsChooser && gsChooser !== PLAYER_NAME) {
                          // not the chooser, skip
                          continue;
                        }
                        // if no chooser specified, allow mafias by default (server will double-check)
                      } catch(e) { /* ignore */ }
                    }
                    pendingActionType = m.action;
                    break;
                  }
                }
              }
              if (pendingActionType) break;
            }
          }

          // show modal when the step has changed OR modal is currently hidden (in case client missed change)
          // but do not re-show if we already submitted the same action for this step
          const alreadySubmittedHere = lastActionSubmitted && lastActionSubmitted.step != null && lastActionSubmitted.step === (step ? step.index : null) && lastActionSubmitted.action === pendingActionType;
          // If server reports this step already completed, don't prompt (helps avoid re-prompt when server moved on)
          const serverStepCompleted = (pdata && pdata.current_night_step_completed) || (gs && gs.current_night_step_completed);
          if (pendingActionType && !alreadySubmittedHere && !serverStepCompleted && (stepChanged || document.getElementById('nightModal').style.display === 'none')) {
            // Acquire modal reference early and atomically mark it opened to avoid races
            const modal = document.getElementById('nightModal');
            try {
              if (modal && modal.dataset && modal.dataset.opened === '1') {
                // already opened by a concurrent callback; mark prompt in progress and skip
                promptInProgress = true;
              } else {
                // mark opened immediately (atomic with respect to this JS execution block)
                if (modal && modal.dataset) modal.dataset.opened = '1';
                promptInProgress = true;
                try { lastShownStepIndex = step ? step.index : null; } catch(e) { lastShownStepIndex = null; }

                // populate clickable target tiles (sorted)
                const targetsEl = document.getElementById('nightTargets');
                targetsEl.innerHTML = '';
                const sorted = alive.slice().sort((a,b)=> a.localeCompare(b));
                for (const p of sorted) {
                  const tile = document.createElement('div');
                  tile.className = 'target-tile';
                  // mark eliminated players as disabled
                  const isElim = (pdata.eliminated_players||[]).includes(p);
                  if (!isElim) tile.classList.add('clickable'); else tile.classList.add('disabled');

                  const nameEl = document.createElement('div');
                  nameEl.className = 'player-name';
                  nameEl.textContent = p;
                  tile.appendChild(nameEl);

                  const actionsRow = document.createElement('div');
                  actionsRow.className = 'tile-actions';

                  // create action buttons depending on pendingActionType
                  function makeBtn(text, cls, onClick) {
                    const b = document.createElement('button');
                    b.className = 'btn';
                    b.style.padding = '0.45rem 0.6rem';
                    b.style.fontSize = '0.9rem';
                    b.style.borderRadius = '8px';
                    b.style.cursor = 'pointer';
                    b.textContent = text;
                    if (cls === 'kill') { b.style.background = '#dc2626'; b.style.color = 'white'; }
                    else if (cls === 'save') { b.style.background = '#059669'; b.style.color = 'white'; }
                    else if (cls === 'check') { b.style.background = '#2563eb'; b.style.color = 'white'; }
                    b.onclick = onClick;
                    return b;
                  }

                  const destructive = (pendingActionType === 'mafia_final' || pendingActionType === 'vigilante_kill' || pendingActionType === 'framer_pick');
                  if (pendingActionType === 'mafia_final' || pendingActionType === 'vigilante_kill') {
                    // destructive: confirm first
                    actionsRow.appendChild(makeBtn('Kill', 'kill', () => {
                      if (isElim) return; openActionConfirm(p, pendingActionType, () => submitNightActionTo(p, pendingActionType));
                    }));
                  } else if (pendingActionType === 'doctor_save' || pendingActionType === 'bodyguard_save') {
                    actionsRow.appendChild(makeBtn('Save', 'save', () => { if (isElim) return; submitNightActionTo(p, pendingActionType); }));
                  } else if (pendingActionType === 'cop_check') {
                    actionsRow.appendChild(makeBtn('Check', 'check', () => { if (isElim) return; submitNightActionTo(p, pendingActionType); }));
                  } else if (pendingActionType === 'sheriff_mute') {
                    actionsRow.appendChild(makeBtn('Mute', 'check', () => { if (isElim) return; submitNightActionTo(p, pendingActionType); }));
                  } else if (pendingActionType === 'framer_pick') {
                    actionsRow.appendChild(makeBtn('Frame', 'kill', () => { if (isElim) return; openActionConfirm(p, pendingActionType, () => submitNightActionTo(p, pendingActionType)); }));
                  } else {
                    // generic action button
                    actionsRow.appendChild(makeBtn('Select', 'check', () => { if (isElim) return; submitNightActionTo(p, pendingActionType); }));
                  }

                  tile.appendChild(actionsRow);
                  targetsEl.appendChild(tile);
                }

                // show appropriate title
                const title = document.getElementById('nightModalTitle');
                title.textContent = pendingActionType.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
                try { modal.style.display = 'flex'; } catch(e) {}
              }
            } catch (e) {
              // fallback to simple display if dataset unsupported
              try { document.getElementById('nightModal').style.display = 'flex'; } catch(e2) {}
              try { lastShownStepIndex = step ? step.index : null; } catch(e3) { lastShownStepIndex = null; }
              promptInProgress = true;
            }
          }
        }
  // track last seen night phase and night_step index to detect changes and avoid duplicate prompts
  // If the night step advanced since we last saw it, clear the lastActionSubmitted so roles can act again
  const prevNightIndex = lastKnownNightIndex;
  lastKnownPhase = gs.phase;
  lastKnownNightIndex = gs.current_night_step ? gs.current_night_step.index : null;
  if (prevNightIndex != null && lastKnownNightIndex != null && prevNightIndex !== lastKnownNightIndex) {
    lastActionSubmitted = null;
    lastShownStepIndex = null;
  }
      } catch (e) {
        // ignore
      }
    }

    // Poll game-state for night-phase actions every 2.5s
    setInterval(checkGamePhaseForActions, 2500);
  </script>
</body>
<script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', function() {
      navigator.serviceWorker.register('/static/sw.js').catch(function(err){ console.warn('SW registration failed:', err); });
    });
  }
</script>
</html>