<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Mafia Host Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="manifest" href="/static/manifest.json">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Mafia Game">
  <link rel="apple-touch-icon" href="/static/mafia_bg_pic.jpg">
  <link rel="stylesheet" href="/static/snazzy.css">
  <style>
    body { 
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; 
      padding: 2rem; 
      background: #0f172a; 
      color: #e2e8f0; 
      min-height: 100vh;
      margin: 0;
    }
    .wrap { max-width: 900px; margin: 0 auto; }
    h1 { 
      margin-top: 0; 
      font-size: 1.8rem; 
      color: #f1f5f9;
    }
    .sub { 
      color: #94a3b8; 
      margin-bottom: 2rem; 
    }
    .panel { 
      background: #1e293b; 
      padding: 1.5rem; 
      margin: 1rem 0; 
      border-radius: 12px; 
      box-shadow: 0 10px 30px rgba(0,0,0,0.3); 
      border: 1px solid #334155;
    }
    .btn { 
      padding: 0.6rem 1rem; 
      font-size: 0.9rem; 
      border: none; 
      border-radius: 8px; 
      cursor: pointer; 
      margin-right: 0.5rem; 
      font-weight: 600;
      transition: all 0.2s ease;
    }
    .btn-success { 
      background: #059669; 
      color: white; 
    }
    .btn-success:hover { 
      background: #047857; 
    }
    .btn-danger { 
      background: #dc2626; 
      color: white; 
    }
    .btn-danger:hover { 
      background: #b91c1c; 
    }
    .btn:disabled { 
      background: #475569; 
      cursor: not-allowed; 
      color: #94a3b8;
    }
    .badge { 
      background: #2563eb; 
      color: white; 
      padding: 0.25rem 0.5rem; 
      border-radius: 6px; 
      font-size: 0.8rem; 
    }
    .status { 
      padding: 1rem; 
      border-radius: 8px; 
      margin-bottom: 1rem; 
    }
    .status.waiting { 
      background: #451a03; 
      color: #fbbf24; 
      border: 1px solid #92400e; 
    }
    .status.ready { 
      background: #064e3b; 
      color: #34d399; 
      border: 1px solid #059669; 
    }
    .count { 
      background: #374151; 
      padding: 0.25rem 0.5rem; 
      border-radius: 4px; 
      font-weight: bold; 
      color: #f1f5f9;
    }
    .small { 
      font-size: 0.85rem; 
      color: #94a3b8; 
    }
    .time { 
      margin-top: 0.5rem; 
    }
    .total-count { 
      margin-top: 1rem; 
      font-weight: bold; 
      color: #f1f5f9;
    }
    .role-input { 
      display: flex; 
      gap: 0.5rem; 
      margin-bottom: 0.5rem; 
      align-items: center; 
    }
    .role-input input[type="text"] { 
      flex: 2; 
      padding: 0.5rem; 
      border: 1px solid #475569; 
      border-radius: 6px; 
      background: #374151;
      color: #f1f5f9;
    }
    .role-input input[type="text"]:focus {
      outline: none;
      border-color: #2563eb;
      box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.2);
    }
    .role-input input[type="number"] { 
      /* make the numeric role count input physically smaller while keeping alignment */
      flex: 0 0 auto;
      width: 4ch;
      max-width: 5rem;
      padding: 0.35rem 0.45rem;
      border: 1px solid #475569; 
      border-radius: 6px; 
      background: #374151;
      color: #f1f5f9;
    }
    /* Faction select styling to match inputs and sizing */
    .role-input select.role-faction {
      flex: 0 0 auto;
      width: 9ch;
      max-width: 8rem;
      padding: 0.35rem 0.45rem;
      border: 1px solid #475569;
      border-radius: 6px;
      background: #374151;
      color: #f1f5f9;
      font-weight: 600;
      -webkit-appearance: none;
      appearance: none;
    }
    .role-input select.role-faction:focus {
      outline: none;
      border-color: #2563eb;
      box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.12);
    }
    .role-input input[type="number"]:focus {
      outline: none;
      border-color: #2563eb;
      box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.2);
    }
    .remove-btn { 
      background: #dc2626; 
      padding: 0.25rem 0.5rem; 
      font-size: 0.8rem; 
      color: white;
    }
    .remove-btn:hover {
      background: #b91c1c;
    }
    
    /* Player roles display styles */
    .player-roles { 
      margin-top: 1rem; 
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 0.75rem;
    }
    .role-card {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.02));
      border: 1px solid rgba(255,255,255,0.04);
      padding: 0.75rem;
      border-radius: 10px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.45);
      transition: transform 220ms cubic-bezier(.2,.9,.2,1), box-shadow 220ms cubic-bezier(.2,.9,.2,1), opacity 220ms ease;
      min-height: 48px;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    /* initial (hidden) state to allow smooth entrance */
    .role-card { opacity: 0; transform: translateY(6px) scale(0.995); }
    .role-card.show { opacity: 1; transform: translateY(0) scale(1); }
    .role-card:hover { transform: translateY(-3px); box-shadow: 0 10px 30px rgba(2,6,23,0.55); }
    .role-card-header { display:flex; align-items:center; gap:0.5rem; }
    .role-card-title { font-weight:700; color: #f1f5f9; }
    .role-card-count { font-size:0.85rem; color:#94a3b8; }
    .role-card.eliminated {
      background: linear-gradient(180deg, rgba(255,0,0,0.03), rgba(0,0,0,0.02));
      border-color: rgba(220,38,38,0.18);
      opacity: 0.85;
    }
    .player-name { 
      font-weight: 600; 
      color: #f1f5f9;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
    }
    .player-role { 
      background: #fbbf24; 
      color: #92400e; 
      padding: 0.25rem 0.75rem; 
      border-radius: 6px; 
      font-weight: bold; 
      font-size: 0.9rem;
      margin-left: auto;
    }
    .player-role.eliminated {
      background: #dc2626;
      color: white;
    }
    .roles-header { 
      font-weight: bold; 
      margin-top: 1rem; 
      margin-bottom: 0.5rem; 
      color: #f1f5f9;
    }
    .faction-section .roles-header {
      font-size: 1rem;
      padding: 0.5rem 0;
      border-bottom: 1px dashed rgba(255,255,255,0.03);
      margin-bottom: 0.75rem;
    }
    .no-assignments { 
      color: #94a3b8; 
      font-style: italic; 
      text-align: center; 
      padding: 1rem;
    }

    /* Player pill style used inside role cards */
    .player-pill {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.35rem 0.55rem;
      background: rgba(255,255,255,0.02);
      border: 1px solid rgba(255,255,255,0.03);
      border-radius: 999px;
      color: #f1f5f9;
      font-weight: 600;
      transition: transform 180ms cubic-bezier(.2,.9,.2,1), background 180ms ease, opacity 180ms ease;
    }
    .player-pill { opacity: 0; transform: translateY(6px); }
    .player-pill.show { opacity: 1; transform: translateY(0); }
    .player-pill:hover { transform: translateY(-2px); background: rgba(255,255,255,0.03); }
    .player-pill .pill-actions { margin-left: 0.5rem; }
    .player-pill.eliminated { opacity: 0.7; text-decoration: line-through; }

  /* small accent dot for role headers */
  .role-accent { width:10px; height:10px; border-radius:50%; display:inline-block; margin-right:0.5rem; box-shadow: 0 2px 8px rgba(0,0,0,0.4); }
    /* Faction badge used in role cards */
    .faction-badge {
      display: inline-block;
      padding: 0.25rem 0.6rem;
      border-radius: 8px;
      font-size: 0.8rem;
      font-weight: 700;
      color: white;
      margin-left: 0.5rem;
      border: 1px solid rgba(255,255,255,0.03);
    }
    .faction-mafia { background: #dc2626; }
    .faction-villagers { background: #059669; }
    .faction-neutral { background: #6b7280; }
    .faction-unknown { background: #374151; color: #f1f5f9; }
    /* Role pool (buttons) */
    .role-pool { margin-top: 1rem; display: grid; gap: 0.75rem; }
    .role-pool-sections { display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 0.75rem; }
    .role-pool-section { background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.02)); padding: 0.75rem; border-radius: 10px; border: 1px solid rgba(255,255,255,0.03); }
    .role-pool-section h4 { margin: 0 0 0.5rem 0; font-size: 0.95rem; color: #f1f5f9; }
    .role-pool-buttons { display:flex; flex-wrap:wrap; gap:0.5rem; }
    .role-pool-btn {
      padding: 0.45rem 0.6rem; border-radius: 8px; border: none; cursor: pointer; font-weight:700; font-size:0.9rem;
      background: rgba(255,255,255,0.02); color: #f1f5f9; display:inline-flex; gap:0.5rem; align-items:center;
      transition: transform 140ms ease, box-shadow 140ms ease, opacity 140ms ease;
    }
    .role-pool-btn:hover { transform: translateY(-2px); box-shadow: 0 6px 18px rgba(0,0,0,0.5); }
    .role-pool-btn small { display:block; font-weight:600; font-size:0.75rem; color: rgba(255,255,255,0.85); }
    .role-pool-btn .role-dot { width:10px; height:10px; border-radius:50%; display:inline-block; margin-right:0.5rem; box-shadow:0 2px 8px rgba(0,0,0,0.35); }
    .role-pool-btn.faction-mafia { background: linear-gradient(180deg,#7f1d1d,#581414); color: #ffeaea; }
    .role-pool-btn.faction-villagers { background: linear-gradient(180deg,#047857,#065f46); color: #eafff4; }
    .role-pool-btn.faction-neutral { background: linear-gradient(180deg,#374151,#1f2937); color: #f1f5f9; }
    .role-pool-btn.faction-unknown { background: linear-gradient(180deg,#111827,#0b1220); color: #cbd5e1; }
    
    /* Player list styling */
    #playerList {
      list-style: none;
      padding: 0;
      margin: 1rem 0;
    }
    #playerList li {
      padding: 0.5rem;
      margin: 0.25rem 0;
      background: #374151;
      border-radius: 6px;
      color: #f1f5f9;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #playerList li.eliminated {
      background: #4c1d1d;
      opacity: 0.7;
    }
    
    /* Kill button styling */
    .kill-btn {
      background: #dc2626;
      color: white;
      padding: 0.25rem 0.5rem;
      font-size: 0.8rem;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .kill-btn:hover {
      background: #b91c1c;
    }
    .kill-btn:disabled {
      background: #475569;
      cursor: not-allowed;
      color: #94a3b8;
    }
    
    /* Eliminated icon */
    .eliminated-icon {
      color: #dc2626;
      font-weight: bold;
      margin-left: 0.5rem;
    }
    
    /* Join link styling */
    code {
      background: #374151;
      color: #fbbf24;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
    }
    .btn-copy {
      padding: 0.35rem 0.6rem;
      font-size: 0.85rem;
      border-radius: 6px;
      margin-left: 0.5rem;
    }
    .copy-status {
      display:inline-block;
      margin-left:0.5rem;
      color:#94a3b8;
      font-size:0.85rem;
      vertical-align: middle;
    }
    
    /* Panel headers */
    h3 {
      margin-top: 0;
      color: #f1f5f9;
      font-size: 1.2rem;
    }
    
    /* Password management styles */
    .password-section {
      background: #1e293b;
      padding: 1.5rem;
      margin: 1rem 0;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
      border: 1px solid #334155;
    }
    .password-input {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1rem;
      align-items: center;
    }
    .password-input input[type="password"] {
      flex: 2;
      padding: 0.5rem;
      border: 1px solid #475569;
      border-radius: 6px;
      background: #374151;
      color: #f1f5f9;
    }
    .password-input input[type="password"]:focus {
      outline: none;
      border-color: #2563eb;
      box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.2);
    }
    .password-status {
      font-size: 0.9rem;
      color: #94a3b8;
      margin-top: 0.5rem;
    }
    
    /* Strikethrough for eliminated players */
    .player-name.eliminated {
      text-decoration: line-through;
      opacity: 0.6;
    }

    .player-role-item .player-name.eliminated {
      text-decoration: line-through;
      opacity: 0.6;
    }

    #playerList li.eliminated .player-name {
      text-decoration: line-through;
      opacity: 0.6;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel" style="display:flex;align-items:center;gap:1rem;justify-content:space-between;padding:1rem 1.25rem;">
      <div style="display:flex;align-items:center;gap:1rem;">
        <div style="width:56px;height:56px;border-radius:12px;background:linear-gradient(135deg,#7f1d1d,#3a0710);display:flex;align-items:center;justify-content:center;font-weight:900;font-size:1.1rem;">M</div>
        <div>
          <div style="font-size:1.25rem;font-weight:900;color:#f7fbff">Mafia Host Dashboard <span class="badge" id="gameStatus">Setup</span></div>
          <div class="sub">Set up roles and wait for players to join.</div>
        </div>
      </div>
      <div style="display:flex;align-items:center;gap:0.5rem">
        <div class="small">Players Joined</div>
        <div class="count" id="playerCount">0</div>
      </div>
    </div>
    
    <!-- Password Management Section -->
    <div class="password-section">
      <h3>Game Password</h3>
      <div class="password-input">
        <input type="password" id="gamePassword" placeholder="Enter password or leave empty..." />
        <button class="btn btn-primary" onclick="setPassword()">Set Password</button>
      </div>
      <div class="password-status" id="passwordStatus">No password set - anyone can join</div>
    </div>

    <div id="statusPanel" class="status waiting">
      <div id="statusText">Waiting for role setup...</div>
    </div>

    <div class="panel">
      <h3>Role Setup</h3>
      <div id="rolesContainer"></div>

      <!-- Role Pool: segmented by faction -->
      <div class="role-pool">
        <div class="roles-header">ðŸ“š Role Pool</div>
        <div class="role-pool-sections" id="rolePoolSections">
          <!-- sections populated by JS -->
        </div>
      </div>

      <!-- Role assignments (moved here so kill buttons appear next to roles) -->
      <div id="playerRolesSection" style="display: none; margin-top: 1rem;">
        <div class="roles-header">ðŸŽ­ Player Role Assignments:</div>
        <div id="playerRolesList" class="player-roles"></div>
      </div>

      <button class="btn" onclick="addRole()" id="addRoleBtn">Add Role</button>
      <div class="total-count">Total Roles: <span id="totalRoles">0</span></div>
    </div>

    <div class="panel">
      <div>Players Joined <span class="count" id="playerCount">0</span></div>
      <ul id="playerList"></ul>
      <div class="small time" id="time">Last updated: â€”</div>
    </div>

    <div class="panel">
      <button class="btn btn-success" onclick="assignRoles()" id="assignBtn" disabled>Assign Roles</button>
      <button class="btn" onclick="restartGame()" id="restartBtn">Restart Game</button>
      <button class="btn btn-danger" onclick="resetGame()" id="resetBtn">Reset Game</button>
      <button class="btn" id="toggleChatBtn" onclick="toggleHostChat()">Lobby Chat</button>
    </div>

    <p class="small">Share the join link: <code id="joinLink"></code>
      <button id="copyJoinBtn" class="btn btn-secondary btn-copy" onclick="copyJoinLink()">Copy</button>
      <span id="copyStatus" class="copy-status" aria-live="polite"></span>
    </p>
  </div>

  <!-- Host Chat Panel (hidden by default) -->
  <div id="hostChatPanel" class="panel" style="display:none; max-width:900px; margin: 0 auto;">
    <h3>Lobby Chat <small class="small">(Host view)</small></h3>
    <div id="hostChatMessages" style="height:260px; overflow:auto; background:#0b1220; padding:0.75rem; border-radius:8px; border:1px solid rgba(255,255,255,0.03);"></div>
    <div style="display:flex; gap:0.5rem; margin-top:0.75rem;">
      <input id="hostChatInput" placeholder="Type a message as Host..." style="flex:1; padding:0.6rem; border-radius:8px; border:1px solid #334155; background:#041027; color:#e2e8f0;" />
      <button class="btn btn-success" onclick="sendHostChat()">Send</button>
      <button class="btn" onclick="toggleHostChat()">Close</button>
    </div>
  </div>

  <div class="footer">
    Created by Scissors. Powered by Sunisha and Diet Coke
  </div>

  <script>
    const playerListEl = document.getElementById('playerList');
    const playerCountEl = document.getElementById('playerCount');
    const timeEl = document.getElementById('time');
    const joinLinkEl = document.getElementById('joinLink');
    const rolesContainer = document.getElementById('rolesContainer');
    const totalRolesEl = document.getElementById('totalRoles');
    const assignBtn = document.getElementById('assignBtn');
    const addRoleBtn = document.getElementById('addRoleBtn');
    const resetBtn = document.getElementById('resetBtn');
    const statusPanel = document.getElementById('statusPanel');
    const statusText = document.getElementById('statusText');
    const gameStatus = document.getElementById('gameStatus');
    const playerRolesSection = document.getElementById('playerRolesSection');
    const playerRolesList = document.getElementById('playerRolesList');
    const gamePasswordEl = document.getElementById('gamePassword');
    const passwordStatusEl = document.getElementById('passwordStatus');

    const ROOM_NAME = '{{ room_name | e }}';
    joinLinkEl.textContent = `${location.protocol}//${location.host}/room/${encodeURIComponent(ROOM_NAME)}`;

    let roles = [];
    let gameStarted = false;
  // Snapshot of last assignments to avoid re-rendering/animating on every poll
  let lastAssignmentsSnapshot = null;

    function escapeHtml(str) {
      const p = document.createElement('p');
      p.innerText = str;
      return p.innerHTML;
    }

    function setPassword() {
      const password = gamePasswordEl.value;
      
      fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/set-player-password`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: `password=${encodeURIComponent(password)}`
      })
      .then(response => response.json())
      .then(data => {
        if (data.success) {
          if (data.password_set) {
            passwordStatusEl.textContent = 'Password set successfully';
            passwordStatusEl.style.color = '#34d399';
          } else {
            passwordStatusEl.textContent = 'Password removed - anyone can join';
            passwordStatusEl.style.color = '#94a3b8';
          }
        }
      })
      .catch(error => {
        console.error('Error setting password:', error);
        passwordStatusEl.textContent = 'Error setting password';
        passwordStatusEl.style.color = '#f87171';
      });
    }

    async function killPlayer(playerName) {
      if (!confirm(`Are you sure you want to eliminate ${playerName}?`)) {
        return;
      }

      try {
        const resp = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/kill-player`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: `player_name=${encodeURIComponent(playerName)}`
        });
        
        const data = await resp.json();
        
        if (data.success) {
          // Refresh to show updated player status
          setTimeout(refresh, 100);
        } else {
          alert('Error eliminating player: ' + data.error);
        }
      } catch (e) {
        console.error('Error eliminating player:', e);
        alert('Error eliminating player: ' + e.message);
      }
    }

    function addRole() {
      const roleDiv = document.createElement('div');
      roleDiv.className = 'role-input';
      roleDiv.innerHTML = `
        <input type="text" placeholder="Role name (e.g., Mafia, Villager)" class="role-name">
        <select class="role-faction">
          <option value="">(auto)</option>
          <option value="Mafia">Mafia</option>
          <option value="Villagers">Villagers</option>
          <option value="Neutral">Neutral</option>
        </select>
        <input type="number" min="1" value="1" class="role-count">
        <button class="btn remove-btn" onclick="removeRole(this)">Remove</button>
      `;
      rolesContainer.appendChild(roleDiv);
      updateTotalRoles();
    }

    // Populate editable role inputs from a server-provided roles list
    function populateRolesFromServer(serverRoles) {
      // serverRoles is expected to be an array of {name, count, faction}
      // Clear existing inputs
      rolesContainer.innerHTML = '';
      if (!serverRoles || !serverRoles.length) {
        // No server-provided roles: leave the container empty. Host can press "Add Role" to add inputs.
        return;
      }

      serverRoles.forEach(r => {
        const roleDiv = document.createElement('div');
        roleDiv.className = 'role-input';
        const name = r.name || '';
        const count = r.count || 1;
        const faction = r.faction || '';
        roleDiv.innerHTML = `
          <input type="text" placeholder="Role name (e.g., Mafia, Villager)" class="role-name" value="${escapeHtml(name)}">
          <select class="role-faction">
            <option value="">(auto)</option>
            <option value="Mafia">Mafia</option>
            <option value="Villagers">Villagers</option>
            <option value="Neutral">Neutral</option>
          </select>
          <input type="number" min="1" value="${count}" class="role-count">
          <button class="btn remove-btn" onclick="removeRole(this)">Remove</button>
        `;
        rolesContainer.appendChild(roleDiv);
        // set faction select after insertion (to avoid HTML escaping issues)
        const sel = roleDiv.querySelector('.role-faction');
        if (sel) sel.value = faction || '';
      });

      updateTotalRoles();
    }

    function removeRole(btn) {
      btn.parentElement.remove();
      updateTotalRoles();
    }

    function updateTotalRoles() {
      const roleCounts = document.querySelectorAll('.role-count');
      let total = 0;
      roleCounts.forEach(input => {
        total += parseInt(input.value) || 0;
      });
      totalRolesEl.textContent = total;
      return total;
    }

    function collectRoles() {
      const roleInputs = document.querySelectorAll('.role-input');
      const collectedRoles = [];
      
      roleInputs.forEach(roleDiv => {
        const nameInput = roleDiv.querySelector('.role-name');
        const factionSelect = roleDiv.querySelector('.role-faction');
        const countInput = roleDiv.querySelector('.role-count');
        const name = nameInput.value.trim();
        const count = parseInt(countInput.value) || 0;
        const faction = factionSelect ? factionSelect.value : '';
        
        if (name && count > 0) {
          collectedRoles.push({ name, count, faction });
        }
      });
      
      return collectedRoles;
    }

    // fetch factions map from server for auto-detect
    let _factionsMap = {};
    async function loadFactionsMap(){
      try{
        const resp = await fetch('/api/factions');
        const data = await resp.json();
        if (data.factions) _factionsMap = data.factions;
      }catch(e){ }
    }

    // auto-detect faction when typing role names
    document.addEventListener('input', (e) => {
      if (!e.target.matches('.role-name')) return;
      const input = e.target;
      const val = input.value.trim().toLowerCase();
      const roleDiv = input.closest('.role-input');
      const sel = roleDiv && roleDiv.querySelector('.role-faction');
      if (!sel) return;
      if (!val){ sel.value = ''; return; }
      // exact match first
      if (_factionsMap[val]) { sel.value = _factionsMap[val]; return; }
      // partial match
      for(const k in _factionsMap){ if (val.includes(k)){ sel.value = _factionsMap[k]; return; } }
      // no match: leave as auto
      sel.value = '';
    });

    // load factions map on start
    loadFactionsMap();

    // Display assignments grouped by faction, then by role
    function displayPlayerRoles(assignments, eliminatedPlayers = []) {
      if (!assignments || Object.keys(assignments).length === 0) {
        playerRolesSection.style.display = 'none';
        return;
      }

      // Build role -> players mapping
      const roleMap = {};
      Object.keys(assignments).forEach(player => {
        const role = assignments[player] || 'Unassigned';
        if (!roleMap[role]) roleMap[role] = [];
        roleMap[role].push(player);
      });

      playerRolesSection.style.display = 'block';
      playerRolesList.innerHTML = '';

      // helper: deterministic color per role name (returns hsl string)
      function roleColor(role) {
        let h = 0;
        for (let i = 0; i < role.length; i++) {
          h = (h * 31 + role.charCodeAt(i)) % 360;
        }
        return `hsl(${h} 75% 55% / 1)`;
      }

      // Build a quick lookup from role name -> faction using server-provided roles when available
      const roleToFaction = {};
      try {
        const rr = window.__roomRoles || [];
        for (const r of rr) {
          if (r && r.name) roleToFaction[r.name] = r.faction || '';
        }
      } catch (e) { /* ignore */ }

      // Group roles under their factions
      const factionMap = {};
      Object.keys(roleMap).forEach(roleName => {
        const faction = roleToFaction[roleName] || '';
        if (!factionMap[faction]) factionMap[faction] = {};
        factionMap[faction][roleName] = roleMap[roleName];
      });

      // Render faction sections in a preferred order
      const preferredOrder = ['Mafia', 'Villagers', 'Neutral', ''];
      const factionsOrdered = [];
      for (const pf of preferredOrder) if (pf in factionMap) factionsOrdered.push(pf);
      Object.keys(factionMap).sort().forEach(f => { if (!factionsOrdered.includes(f)) factionsOrdered.push(f); });

      const sectionCards = [];

      for (const factionName of factionsOrdered) {
        const rolesForFaction = factionMap[factionName] || {};

        const section = document.createElement('div');
        section.className = 'faction-section panel';

        const sectHeader = document.createElement('div');
        sectHeader.className = 'roles-header';
        const displayFaction = factionName || 'Unspecified';
        const countPlayers = Object.values(rolesForFaction).reduce((acc, arr) => acc + (arr ? arr.length : 0), 0);
        sectHeader.textContent = displayFaction + ' (' + countPlayers + ')';
        section.appendChild(sectHeader);

        const rolesWrap = document.createElement('div');
        rolesWrap.style.display = 'grid';
        rolesWrap.style.gridTemplateColumns = 'repeat(auto-fit, minmax(220px, 1fr))';
        rolesWrap.style.gap = '0.75rem';

        Object.keys(rolesForFaction).sort().forEach(roleName => {
          const card = document.createElement('div');
          card.className = 'role-card';

          const header = document.createElement('div');
          header.className = 'role-card-header';
          const accent = document.createElement('span');
          accent.className = 'role-accent';
          accent.style.background = roleColor(roleName);
          header.appendChild(accent);

          const title = document.createElement('div');
          title.className = 'role-card-title';
          title.textContent = roleName;
          header.appendChild(title);

          const count = document.createElement('div');
          count.className = 'role-card-count';
          count.textContent = `(${roleMap[roleName].length})`;
          header.appendChild(count);

          const rf = roleToFaction[roleName] || '';
          if (rf) {
            const fb = document.createElement('span');
            const cls = 'faction-' + rf.toLowerCase().replace(/[^a-z0-9]+/g, '') || 'unknown';
            fb.className = 'faction-badge ' + (cls || 'faction-unknown');
            fb.textContent = rf;
            header.appendChild(fb);
          }

          card.appendChild(header);

          const playersWrap = document.createElement('div');
          playersWrap.style.display = 'flex';
          playersWrap.style.flexWrap = 'wrap';
          playersWrap.style.gap = '0.5rem';

          rolesForFaction[roleName].sort().forEach(playerName => {
            const isEliminated = eliminatedPlayers.includes(playerName);
            const pill = document.createElement('div');
            pill.className = 'player-pill' + (isEliminated ? ' eliminated' : '');

            const nameSpan = document.createElement('span');
            nameSpan.textContent = playerName;
            // keep role-assignment pill names white/default in the host UI
            pill.appendChild(nameSpan);

            if (isEliminated) {
              const skull = document.createElement('span');
              skull.className = 'eliminated-icon';
              skull.textContent = 'ðŸ’€';
              pill.appendChild(skull);
            }

            const actions = document.createElement('span');
            actions.className = 'pill-actions';
            const btn = document.createElement('button');
            btn.className = 'kill-btn';
            btn.textContent = isEliminated ? 'Eliminated' : 'Kill';
            if (isEliminated) btn.disabled = true;
            btn.onclick = () => killPlayer(playerName);
            actions.appendChild(btn);

            pill.appendChild(actions);
            playersWrap.appendChild(pill);
          });

          card.appendChild(playersWrap);
          rolesWrap.appendChild(card);
          sectionCards.push(card);
        });

        section.appendChild(rolesWrap);
        playerRolesList.appendChild(section);
      }

      requestAnimationFrame(() => {
        sectionCards.forEach(card => {
          card.classList.add('show');
          card.querySelectorAll('.player-pill').forEach((p, i) => {
            setTimeout(() => p.classList.add('show'), i * 30);
          });
        });
      });
    }

    async function syncRoles() {
      const currentRoles = collectRoles();
      
      try {
        // Don't reset if game already started
        const statusResp = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/players`);
        const statusData = await statusResp.json();
        if (statusData.game_started) {
          return;
        }
        
        // Clear server roles only (not players!)
        await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/reset-roles`, { method: 'POST' });
        
        // Add each role
        for (const role of currentRoles) {
          const resp = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/roles`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: `role_name=${encodeURIComponent(role.name)}&role_count=${role.count}&role_faction=${encodeURIComponent(role.faction || '')}`
          });
          if (!resp.ok) {
            console.error('Failed to add role:', role);
          }
        }
      } catch (e) {
        console.error('Error syncing roles:', e);
        throw e;
      }
    }

    async function assignRoles() {
      // First sync roles to server
      await syncRoles();
      
      // Small delay to ensure sync completes
      await new Promise(resolve => setTimeout(resolve, 100));
      
      try {
        const resp = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/assign`, { method: 'POST' });
        const data = await resp.json();
        
        if (data.success) {
          gameStarted = true;
          addRoleBtn.disabled = true;
          assignBtn.disabled = true;
          document.querySelectorAll('.role-name, .role-count, .remove-btn').forEach(el => el.disabled = true);
          gameStatus.textContent = 'Started';
          statusText.textContent = 'Game started! Roles have been assigned.';
          statusPanel.className = 'status ready';
          
          // Refresh to show the role assignments
          setTimeout(refresh, 500);
        } else {
          alert('Error: ' + data.error);
          console.error('Assignment error:', data);
        }
      } catch (e) {
        console.error('Error assigning roles:', e);
        alert('Error assigning roles: ' + e.message);
      }
    }

    async function resetGame() {
      if (confirm('Are you sure you want to reset the game? This will clear all players and roles.')) {
        try {
          await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/reset`, { method: 'POST' });
          location.reload();
        } catch (e) {
          alert('Error resetting game');
        }
      }
    }

    async function restartGame() {
      if (!confirm('Restart the game? This will clear current assignments and eliminated players but keep players and roles.')) return;
      try {
        const resp = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/restart`, { method: 'POST' });
        const data = await resp.json();
        if (data.success) {
          // Clear UI assignment snapshot and refresh to show lobby state
          lastAssignmentsSnapshot = null;
          // Refresh to get the current server roles and player list
          await refresh();
          // After refresh, if server provided roles, populate editable inputs so host can tweak them
          try {
            const r = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/players`, { cache: 'no-store' });
            const d = await r.json();
            if (d.roles && Array.isArray(d.roles) && d.roles.length) {
              populateRolesFromServer(d.roles);
            }
          } catch (e) {
            console.warn('Could not fetch server roles to populate inputs after restart', e);
          }

          alert('Game restarted â€” roles preserved and pre-filled for editing. Players remain in lobby.');
        } else {
          alert('Error restarting game: ' + (data.error || 'unknown'));
        }
      } catch (e) {
        console.error('Error restarting game', e);
        alert('Error restarting game');
      }
    }

    async function refresh() {
      try {
        const resp = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/players`, { cache: 'no-store' });
        const data = await resp.json();
        // store server-side roles info (if provided elsewhere)
        if (data.roles) window.__roomRoles = data.roles;
        
        playerCountEl.textContent = data.count;
        // expose per-player chat colors for use elsewhere in the host UI
        window.__chatColors = data.chat_colors || {};
        
        playerListEl.innerHTML = '';
        for (const playerName of data.players) {
          const isEliminated = data.eliminated_players && data.eliminated_players.includes(playerName);
          const li = document.createElement('li');
          li.className = isEliminated ? 'eliminated' : '';
          
          const playerNameSpan = document.createElement('span');
          playerNameSpan.className = isEliminated ? 'player-name eliminated' : 'player-name';
          // keep player list names white/default in the host UI (colors are only shown in lobby chat)
          playerNameSpan.innerHTML = escapeHtml(playerName) + (isEliminated ? ' <span class="eliminated-icon">ðŸ’€</span>' : '');
          
          li.appendChild(playerNameSpan);

          // Add Kick button (host-only action)
          const kickActions = document.createElement('span');
          kickActions.style.display = 'inline-flex';
          kickActions.style.alignItems = 'center';
          kickActions.style.gap = '0.5rem';

          const kickBtn = document.createElement('button');
          kickBtn.className = 'kill-btn';
          kickBtn.textContent = 'Kick';
          kickBtn.onclick = () => kickPlayerFromHost(playerName);
          kickActions.appendChild(kickBtn);

          li.appendChild(kickActions);
          playerListEl.appendChild(li);
        }
        
        // If server provides saved roles and the local inputs are still default/empty, prefill them
        try {
          const localRoleNames = Array.from(document.querySelectorAll('.role-name')).map(i => i.value.trim()).filter(Boolean);
          if (data.roles && Array.isArray(data.roles) && data.roles.length && (!localRoleNames.length || (localRoleNames.length === 1 && localRoleNames[0] === ''))) {
            populateRolesFromServer(data.roles);
          }
        } catch (e) { /* ignore */ }

        // Display role assignments if game has started
        if (data.game_started && data.assignments) {
          const snapshot = JSON.stringify({ assignments: data.assignments, eliminated: data.eliminated_players || [] });
          if (snapshot !== lastAssignmentsSnapshot) {
            // only re-render when assignments or eliminated players changed
            lastAssignmentsSnapshot = snapshot;
            displayPlayerRoles(data.assignments, data.eliminated_players || []);
          }
        } else {
          lastAssignmentsSnapshot = null;
          playerRolesSection.style.display = 'none';
        }
        
        // Get frontend total roles
        const frontendTotalRoles = updateTotalRoles();
        
        // Check if we can start based on frontend roles (not server roles)
        const canStart = data.count > 0 && frontendTotalRoles > 0 && data.count === frontendTotalRoles && !data.game_started;
        assignBtn.disabled = !canStart;
        
        if (data.game_started) {
          gameStarted = true;
          addRoleBtn.disabled = true;
          assignBtn.disabled = true;
          document.querySelectorAll('.role-name, .role-count, .remove-btn').forEach(el => el.disabled = true);
          gameStatus.textContent = 'Started';
          statusText.textContent = 'Game started! Roles have been assigned.';
          statusPanel.className = 'status ready';
        } else if (canStart) {
          statusText.textContent = `Ready to start! ${data.count} players joined, ${frontendTotalRoles} roles configured.`;
          statusPanel.className = 'status ready';
        } else {
          statusText.textContent = `Waiting... ${data.count}/${frontendTotalRoles} players joined.`;
          statusPanel.className = 'status waiting';
        }

        // Ensure host can add roles again when the game is not started (e.g., after a restart)
        try {
          addRoleBtn.disabled = !!data.game_started;
        } catch (e) { /* ignore if button not present */ }
        
        // Update password status
        if (data.password_set) {
          passwordStatusEl.textContent = 'Password is set';
          passwordStatusEl.style.color = '#34d399';
        } else {
          passwordStatusEl.textContent = 'No password set - anyone can join';
          passwordStatusEl.style.color = '#94a3b8';
        }
        
        const now = new Date();
        timeEl.textContent = 'Last updated: ' + now.toLocaleTimeString();
      } catch (e) {
        timeEl.textContent = 'Last updated: (error contacting server)';
      }
    }

    // Host action: kick a player from the lobby (must be host-authenticated via cookie)
    async function kickPlayerFromHost(playerName) {
      if (!confirm(`Kick ${playerName} from the lobby? They will need to rejoin.`)) return;
      try {
        const resp = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/kick-player`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: `player_name=${encodeURIComponent(playerName)}`
        });
        const data = await resp.json();
        if (data.success) {
          // refresh to update UI
          setTimeout(refresh, 150);
        } else {
          alert('Kick failed: ' + (data.error || 'unknown'));
        }
      } catch (e) {
        console.error('Kick error', e);
        alert('Error kicking player: ' + e.message);
      }
    }

    // Add event listeners for role count changes
    document.addEventListener('input', (e) => {
      if (e.target.classList.contains('role-count') || e.target.classList.contains('role-name')) {
        updateTotalRoles();
        // Trigger a refresh to update button state
        setTimeout(refresh, 100);
      }
    });

  // No initial role added automatically. Host may click "Add Role" to create inputs.

    // --- Role pool logic ---
    // Fetch role descriptions and render pool segmented by faction
    async function loadRolePool() {
      try {
        const resp = await fetch('/role_descriptions.json', { cache: 'no-store' });
        const roles = await resp.json();

        // Try to get faction mapping from previously loaded map or fallback to /api/factions
        let factionsMap = _factionsMap || {};
        if (!factionsMap || Object.keys(factionsMap).length === 0) {
          try {
            const r = await fetch('/api/factions');
            const d = await r.json();
            if (d.factions) factionsMap = d.factions;
          } catch (e) { /* ignore */ }
        }

        // Build an inverted map: factionName -> [roleNames]
        const byFaction = {};
        for (const [roleName, desc] of Object.entries(roles)) {
          const key = (factionsMap[roleName.toLowerCase()] || '') || '';
          if (!byFaction[key]) byFaction[key] = [];
          byFaction[key].push({ name: roleName, desc });
        }

        // Preferred order
        const preferredOrder = ['Mafia', 'Villagers', 'Neutral', ''];
        const sectionsEl = document.getElementById('rolePoolSections');
        sectionsEl.innerHTML = '';

        const allFactions = new Set([...Object.keys(byFaction)]);
        const ordered = [];
        for (const pf of preferredOrder) if (allFactions.has(pf)) { ordered.push(pf); allFactions.delete(pf); }
        for (const f of Array.from(allFactions).sort()) ordered.push(f);

        for (const faction of ordered) {
          const sect = document.createElement('div');
          sect.className = 'role-pool-section';
          const h4 = document.createElement('h4');
          h4.textContent = faction || 'Unspecified';
          sect.appendChild(h4);

          const wrap = document.createElement('div');
          wrap.className = 'role-pool-buttons';

          (byFaction[faction] || []).sort((a,b)=>a.name.localeCompare(b.name)).forEach(r => {
            const btn = document.createElement('button');
            btn.className = 'role-pool-btn';
            const cls = 'faction-' + ((faction||'unknown').toLowerCase().replace(/[^a-z0-9]+/g, ''));
            btn.classList.add(cls);
            btn.title = r.desc || '';
            btn.innerHTML = `<span class="role-dot" style="background:${dotColorForRole(r.name)}"></span><span>${escapeHtml(r.name)}</span>`;
            btn.onclick = () => onRolePoolClick(r.name, faction);
            wrap.appendChild(btn);
          });

          sect.appendChild(wrap);
          sectionsEl.appendChild(sect);
        }
      } catch (e) {
        console.error('Failed to load role pool', e);
      }
    }

    // Generate a small deterministic color for the role dot
    function dotColorForRole(role) {
      let h = 0;
      for (let i = 0; i < role.length; i++) h = (h * 31 + role.charCodeAt(i)) % 360;
      return `hsl(${h} 70% 55% / 1)`;
    }

    // When host clicks a role in the pool: add it to inputs or increment existing count
    function onRolePoolClick(roleName, factionName) {
      // find existing role input with same name (case-insensitive)
      const inputs = Array.from(document.querySelectorAll('.role-input'));
      for (const div of inputs) {
        const nameInput = div.querySelector('.role-name');
        const countInput = div.querySelector('.role-count');
        const factionSelect = div.querySelector('.role-faction');
        if (!nameInput) continue;
        if (nameInput.value.trim().toLowerCase() === roleName.toLowerCase()) {
          // increment count
          countInput.value = (parseInt(countInput.value) || 0) + 1;
          updateTotalRoles();
          setTimeout(refresh, 50);
          return;
        }
      }

      // otherwise add new role input prefilled
      const roleDiv = document.createElement('div');
      roleDiv.className = 'role-input';
      roleDiv.innerHTML = `
        <input type="text" placeholder="Role name (e.g., Mafia, Villager)" class="role-name" value="${escapeHtml(roleName)}">
        <select class="role-faction">
          <option value="">(auto)</option>
          <option value="Mafia">Mafia</option>
          <option value="Villagers">Villagers</option>
          <option value="Neutral">Neutral</option>
        </select>
        <input type="number" min="1" value="1" class="role-count">
        <button class="btn remove-btn" onclick="removeRole(this)">Remove</button>
      `;
      rolesContainer.appendChild(roleDiv);
      // set faction select
      const sel = roleDiv.querySelector('.role-faction');
      if (sel) sel.value = factionName || '';
      updateTotalRoles();
      setTimeout(refresh, 50);
    }

    // Load role pool now
    loadRolePool();

    // Poll every second
    refresh();
    setInterval(refresh, 1000);
    
    // --- Host chat logic ---
    let hostChatOpen = false;
    let hostChatEventSource = null;
    const hostChatMessagesEl = () => document.getElementById('hostChatMessages');

    function toggleHostChat() {
      hostChatOpen = !hostChatOpen;
      const panel = document.getElementById('hostChatPanel');
      const btn = document.getElementById('toggleChatBtn');
      if (hostChatOpen) {
        panel.style.display = 'block';
        btn.textContent = 'Close Chat';
        startHostChatStream();
      } else {
        panel.style.display = 'none';
        btn.textContent = 'Lobby Chat';
        stopHostChatStream();
      }
    }

    function startHostChatStream() {
      if (hostChatEventSource) return;
      try {
        hostChatEventSource = new EventSource(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/chat/stream`);
        hostChatEventSource.onmessage = (e) => {
          try {
            const payload = JSON.parse(e.data);
            if (payload.messages) payload.messages.forEach(m => renderHostChatMessage(m));
            if (payload.message) renderHostChatMessage(payload.message);
          } catch (err) { console.warn('Host chat parse error', err); }
        };
        hostChatEventSource.onerror = (err) => {
          console.warn('Host chat SSE error', err);
          // Attempt to reconnect
          stopHostChatStream();
          setTimeout(() => startHostChatStream(), 1200);
        };
      } catch (e) {
        console.warn('Host chat start failed', e);
      }
    }

    function stopHostChatStream() {
      if (hostChatEventSource) {
        hostChatEventSource.close();
        hostChatEventSource = null;
      }
    }

    function renderHostChatMessage(m) {
      if (!m || !m.sender) return;
      const el = document.createElement('div');
      el.style.padding = '0.35rem 0.5rem';
      el.style.borderBottom = '1px dashed rgba(255,255,255,0.02)';
      // Use the server-provided per-sender color when available so host view matches player colors
      const senderColor = m.color || '#f1f5f9';
      el.innerHTML = `<strong style="color:${senderColor}">${escapeHtml(m.sender)}</strong>: ${escapeHtml(m.text)}`;
      hostChatMessagesEl().appendChild(el);
      hostChatMessagesEl().scrollTop = hostChatMessagesEl().scrollHeight;
    }

    async function sendHostChat() {
      const input = document.getElementById('hostChatInput');
      const text = input.value.trim();
      if (!text) return;
      try {
        const resp = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/chat`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: `message=${encodeURIComponent(text)}`
        });
        const d = await resp.json();
        if (d.success) {
          input.value = '';
        } else {
          alert('Chat send failed: ' + (d.error || 'unknown'));
        }
      } catch (e) {
        console.error('Send host chat error', e);
        alert('Error sending chat');
      }
    }

    // Allow pressing Enter in the host chat input to send the message.
    // This mirrors typical chat UX and does not interfere with other handlers.
    try {
      const _hostChatInput = document.getElementById('hostChatInput');
      if (_hostChatInput) {
        _hostChatInput.addEventListener('keydown', (e) => {
          // Only trigger on Enter without modifier keys
          if (e.key === 'Enter' && !e.shiftKey && !e.ctrlKey && !e.metaKey && !e.altKey) {
            e.preventDefault();
            // call the existing sendHostChat (async) and ignore its promise here
            try { sendHostChat(); } catch (err) { console.warn('sendHostChat failed on Enter', err); }
          }
        });
      }
    } catch (e) { /* ignore DOM hookup errors */ }
  </script>
  <script>
    async function copyJoinLink() {
      const txt = joinLinkEl.textContent || '';
      const statusEl = document.getElementById('copyStatus');
      try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(txt);
        } else {
          // fallback
          const ta = document.createElement('textarea');
          ta.value = txt;
          document.body.appendChild(ta);
          ta.select();
          document.execCommand('copy');
          ta.remove();
        }
        statusEl.textContent = 'Copied!';
        setTimeout(() => { statusEl.textContent = ''; }, 2000);
      } catch (e) {
        console.error('Copy failed', e);
        statusEl.textContent = 'Copy failed';
        setTimeout(() => { statusEl.textContent = ''; }, 2000);
      }
    }
  </script>
</body>
<script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', function() {
      navigator.serviceWorker.register('/static/sw.js').catch(function(err){ console.warn('SW registration failed:', err); });
    });
  }
</script>
</html>