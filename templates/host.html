<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Mafia Host Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="manifest" href="/static/manifest.json">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Mafia Game">
  <link rel="apple-touch-icon" href="/static/mafia_bg_pic.jpg">
  <script>
    // Mark touch-capable devices so CSS can avoid :hover rules on them.
    try {
      if ('ontouchstart' in window || (navigator.maxTouchPoints && navigator.maxTouchPoints > 0)) {
        document.documentElement.classList.add('has-touch');
      }
    } catch (e) {}
  </script>
  <!-- Host reveal overlay and elimination log -->
  <div class="reveal-overlay" id="hostRevealOverlay" style="display:none; align-items:center; justify-content:center;">
    <div class="reveal-card" role="dialog" aria-modal="true">
      <div class="reveal-name" id="hostRevealName">Player</div>
      <div class="reveal-role" id="hostRevealRole">Role</div>
      <div class="reveal-cause" id="hostRevealCause">Cause</div>
      <div id="hostEliminationLog" style="max-height:40vh; overflow:auto; margin-top:0.75rem; background:#071024; border-radius:8px; padding:0.6rem; border:1px solid rgba(255,255,255,0.03); text-align:left; font-size:0.95rem;"></div>
      <div style="display:flex; gap:0.5rem; justify-content:center; margin-top:0.6rem;">
        <button class="btn" onclick="hideHostRevealOverlay()">Close</button>
        <button class="btn btn-primary" onclick="copyHostEliminationLog()">Copy Log</button>
      </div>
    </div>
  </div>
  <style>
    body { 
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; 
      padding: 2rem; 
      background: #0f172a; 
      color: #e2e8f0; 
      min-height: 100vh;
      margin: 0;
    }
    .wrap { max-width: 900px; margin: 0 auto; }
    h1 { 
      margin-top: 0; 
      font-size: 1.8rem; 
      color: #f1f5f9;
    }
    .sub { 
      color: #94a3b8; 
      margin-bottom: 2rem; 
    }
    .panel { 
      background: #1e293b; 
      padding: 1.5rem; 
      margin: 1rem 0; 
      border-radius: 12px; 
      box-shadow: 0 10px 30px rgba(0,0,0,0.3); 
      border: 1px solid #334155;
    }
    .btn { 
      padding: 0.6rem 1rem; 
      font-size: 0.9rem; 
      border: none; 
      border-radius: 8px; 
      cursor: pointer; 
      margin-right: 0.5rem; 
      font-weight: 600;
      transition: all 0.2s ease;
    }
    .btn-success { 
      background: #059669; 
      color: white; 
    }
    html:not(.has-touch) .btn-success:hover { 
      background: #047857; 
    }
    .btn-danger { 
      background: #dc2626; 
      color: white; 
    }
    html:not(.has-touch) .btn-danger:hover { 
      background: #b91c1c; 
    }
    .btn:disabled { 
      background: #475569; 
      cursor: not-allowed; 
      color: #94a3b8;
    }
    .badge { 
      background: #2563eb; 
      color: white; 
      padding: 0.25rem 0.5rem; 
      border-radius: 6px; 
      font-size: 0.8rem; 
    }
    .status { 
      padding: 1rem; 
      border-radius: 8px; 
      margin-bottom: 1rem; 
    }
    .status.waiting { 
      background: #451a03; 
      color: #fbbf24; 
      border: 1px solid #92400e; 
    }
    .status.ready { 
      background: #064e3b; 
      color: #34d399; 
      border: 1px solid #059669; 
    }
    .count { 
      background: #374151; 
      padding: 0.25rem 0.5rem; 
      border-radius: 4px; 
      font-weight: bold; 
      color: #f1f5f9;
    }
    .small { 
      font-size: 0.85rem; 
      color: #94a3b8; 
    }
    .time { 
      margin-top: 0.5rem; 
    }
    .total-count { 
      margin-top: 1rem; 
      font-weight: bold; 
      color: #f1f5f9;
    }
    .role-input { 
      display: flex; 
      gap: 0.5rem; 
      margin-bottom: 0.5rem; 
      align-items: center; 
    }
    .role-input input[type="text"] { 
      flex: 2; 
      padding: 0.5rem; 
      border: 1px solid #475569; 
      border-radius: 6px; 
      background: #374151;
      color: #f1f5f9;
    }
    .role-input input[type="text"]:focus {
      outline: none;
      border-color: #2563eb;
      box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.2);
    }
    .role-input input[type="number"] { 
      /* make the numeric role count input physically smaller while keeping alignment */
      flex: 0 0 auto;
      width: 4ch;
      max-width: 5rem;
      padding: 0.35rem 0.45rem;
      border: 1px solid #475569; 
      border-radius: 6px; 
      background: #374151;
      color: #f1f5f9;
    }
    /* Faction select styling to match inputs and sizing */
    .role-input select.role-faction {
      flex: 0 0 auto;
      width: 9ch;
      max-width: 8rem;
      padding: 0.35rem 0.45rem;
      border: 1px solid #475569;
      border-radius: 6px;
      background: #374151;
      color: #f1f5f9;
      font-weight: 600;
      -webkit-appearance: none;
      appearance: none;
    }
    .role-input select.role-faction:focus {
      outline: none;
      border-color: #2563eb;
      box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.12);
    }
    .role-input input[type="number"]:focus {
      outline: none;
      border-color: #2563eb;
      box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.2);
    }
    .remove-btn { 
      background: #dc2626; 
      padding: 0.25rem 0.5rem; 
      font-size: 0.8rem; 
      color: white;
    }
    html:not(.has-touch) .remove-btn:hover {
      background: #b91c1c;
    }
    
    /* Player roles display styles */
    .player-roles { 
      margin-top: 1rem; 
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 0.75rem;
    }
    .role-card {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.02));
      border: 1px solid rgba(255,255,255,0.04);
      padding: 0.75rem;
      border-radius: 10px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.45);
      transition: transform 220ms cubic-bezier(.2,.9,.2,1), box-shadow 220ms cubic-bezier(.2,.9,.2,1), opacity 220ms ease;
      min-height: 48px;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    /* initial (hidden) state to allow smooth entrance */
    .role-card { opacity: 0; transform: translateY(6px) scale(0.995); }
    .role-card.show { opacity: 1; transform: translateY(0) scale(1); }
  html:not(.has-touch) .role-card:hover { transform: translateY(-3px); box-shadow: 0 10px 30px rgba(2,6,23,0.55); }
    .role-card-header { display:flex; align-items:center; gap:0.5rem; }
    .role-card-title { font-weight:700; color: #f1f5f9; }
    .role-card-count { font-size:0.85rem; color:#94a3b8; }
    .role-card.eliminated {
      background: linear-gradient(180deg, rgba(255,0,0,0.03), rgba(0,0,0,0.02));
      border-color: rgba(220,38,38,0.18);
      opacity: 0.85;
    }
    .player-name { 
      font-weight: 600; 
      color: #f1f5f9;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
    }
    .player-role { 
      background: #fbbf24; 
      color: #92400e; 
      padding: 0.25rem 0.75rem; 
      border-radius: 6px; 
      font-weight: bold; 
      font-size: 0.9rem;
      margin-left: auto;
    }
    .player-role.eliminated {
      background: #dc2626;
      color: white;
    }
    .roles-header { 
      font-weight: bold; 
      margin-top: 1rem; 
      margin-bottom: 0.5rem; 
      color: #f1f5f9;
    }
    .faction-section .roles-header {
      font-size: 1rem;
      padding: 0.5rem 0;
      border-bottom: 1px dashed rgba(255,255,255,0.03);
      margin-bottom: 0.75rem;
    }
    .no-assignments { 
      color: #94a3b8; 
      font-style: italic; 
      text-align: center; 
      padding: 1rem;
    }

    /* Player pill style used inside role cards */
    .player-pill {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.35rem 0.55rem;
      background: rgba(255,255,255,0.02);
      border: 1px solid rgba(255,255,255,0.03);
      border-radius: 999px;
      color: #f1f5f9;
      font-weight: 600;
      transition: transform 180ms cubic-bezier(.2,.9,.2,1), background 180ms ease, opacity 180ms ease;
    }
    .player-pill { opacity: 0; transform: translateY(6px); }
    .player-pill.show { opacity: 1; transform: translateY(0); }
  html:not(.has-touch) .player-pill:hover { transform: translateY(-2px); background: rgba(255,255,255,0.03); }
    .player-pill .pill-actions { margin-left: 0.5rem; }
    .player-pill.eliminated { opacity: 0.7; text-decoration: line-through; }

  /* small accent dot for role headers */
  .role-accent { width:10px; height:10px; border-radius:50%; display:inline-block; margin-right:0.5rem; box-shadow: 0 2px 8px rgba(0,0,0,0.4); }
    /* Faction badge used in role cards */
    .faction-badge {
      display: inline-block;
      padding: 0.25rem 0.6rem;
      border-radius: 8px;
      font-size: 0.8rem;
      font-weight: 700;
      color: white;
      margin-left: 0.5rem;
      border: 1px solid rgba(255,255,255,0.03);
    }
    .faction-mafia { background: #dc2626; }
    .faction-villagers { background: #059669; }
    .faction-neutral { background: #6b7280; }
    .faction-unknown { background: #374151; color: #f1f5f9; }
    /* Role pool (buttons) */
    .role-pool { margin-top: 1rem; display: grid; gap: 0.75rem; }
    .role-pool-sections { display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 0.75rem; }
    .role-pool-section { background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.02)); padding: 0.75rem; border-radius: 10px; border: 1px solid rgba(255,255,255,0.03); }
    .role-pool-section h4 { margin: 0 0 0.5rem 0; font-size: 0.95rem; color: #f1f5f9; }
    .role-pool-buttons { display:flex; flex-wrap:wrap; gap:0.5rem; }
    .role-pool-btn {
      padding: 0.45rem 0.6rem; border-radius: 8px; border: none; cursor: pointer; font-weight:700; font-size:0.9rem;
      background: rgba(255,255,255,0.02); color: #f1f5f9; display:inline-flex; gap:0.5rem; align-items:center;
      transition: transform 140ms ease, box-shadow 140ms ease, opacity 140ms ease;
    }
  html:not(.has-touch) .role-pool-btn:hover { transform: translateY(-2px); box-shadow: 0 6px 18px rgba(0,0,0,0.5); }
    .role-pool-btn small { display:block; font-weight:600; font-size:0.75rem; color: rgba(255,255,255,0.85); }
    .role-pool-btn .role-dot { width:10px; height:10px; border-radius:50%; display:inline-block; margin-right:0.5rem; box-shadow:0 2px 8px rgba(0,0,0,0.35); }
    .role-pool-btn.faction-mafia { background: linear-gradient(180deg,#7f1d1d,#581414); color: #ffeaea; }
    .role-pool-btn.faction-villagers { background: linear-gradient(180deg,#047857,#065f46); color: #eafff4; }
    .role-pool-btn.faction-neutral { background: linear-gradient(180deg,#374151,#1f2937); color: #f1f5f9; }
    .role-pool-btn.faction-unknown { background: linear-gradient(180deg,#111827,#0b1220); color: #cbd5e1; }
    
    /* Player list styling */
    #playerList {
      list-style: none;
      padding: 0;
      margin: 1rem 0;
    }
    #playerList li {
      padding: 0.5rem;
      margin: 0.25rem 0;
      background: #374151;
      border-radius: 6px;
      color: #f1f5f9;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #playerList li.eliminated {
      background: #4c1d1d;
      opacity: 0.7;
    }
    
    /* Kill button styling */
    .kill-btn {
      background: #dc2626;
      color: white;
      padding: 0.25rem 0.5rem;
      font-size: 0.8rem;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    html:not(.has-touch) .kill-btn:hover {
      background: #b91c1c;
    }
    .kill-btn:disabled {
      background: #475569;
      cursor: not-allowed;
      color: #94a3b8;
    }
    
    /* Eliminated icon */
    .eliminated-icon {
      color: #dc2626;
      font-weight: bold;
      margin-left: 0.5rem;
    }
    
    /* Join link styling */
    code {
      background: #374151;
      color: #fbbf24;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
    }
    .btn-copy {
      padding: 0.35rem 0.6rem;
      font-size: 0.85rem;
      border-radius: 6px;
      margin-left: 0.5rem;
    }
    .copy-status {
      display:inline-block;
      margin-left:0.5rem;
      color:#94a3b8;
      font-size:0.85rem;
      vertical-align: middle;
    }
    
    /* Panel headers */
    h3 {
      margin-top: 0;
      color: #f1f5f9;
      font-size: 1.2rem;
    }
    
    /* Password management styles */
    .password-section {
      background: #1e293b;
      padding: 1.5rem;
      margin: 1rem 0;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
      border: 1px solid #334155;
    }
    .password-input {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1rem;
      align-items: center;
    }
    .password-input input[type="password"] {
      flex: 2;
      padding: 0.5rem;
      border: 1px solid #475569;
      border-radius: 6px;
      background: #374151;
      color: #f1f5f9;
    }
    .password-input input[type="password"]:focus {
      outline: none;
      border-color: #2563eb;
      box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.2);
    }
    .password-status {
      font-size: 0.9rem;
      color: #94a3b8;
      margin-top: 0.5rem;
    }
    
    /* Strikethrough for eliminated players */
    .player-name.eliminated {
      text-decoration: line-through;
      opacity: 0.6;
    }

    .player-role-item .player-name.eliminated {
      text-decoration: line-through;
      opacity: 0.6;
    }

    #playerList li.eliminated .player-name {
      text-decoration: line-through;
      opacity: 0.6;
    }
  </style>
</head>
<body>
  <div class="wrap">

    <!-- host mute init moved to bottom script for safe execution -->
    <h1>Mafia Host Dashboard <span class="badge" id="gameStatus">Setup</span></h1>
    <div class="sub">Set up roles and wait for players to join.</div>
    
    <!-- Password Management Section -->
    <div class="password-section">
      <h3>Game Password</h3>
      <div class="password-input">
        <input type="password" id="gamePassword" placeholder="Enter password or leave empty..." />
        <button class="btn btn-primary" onclick="setPassword()">Set Password</button>
      </div>
      <div class="password-status" id="passwordStatus">No password set - anyone can join</div>
    </div>

    <div id="statusPanel" class="status waiting">
      <div id="statusText">Waiting for role setup...</div>
    </div>

    <div class="panel">
      <h3>Role Setup</h3>
      <div id="rolesContainer"></div>

      <!-- Role Pool: segmented by faction -->
      <div class="role-pool">
        <div class="roles-header">📚 Role Pool</div>
        <div class="role-pool-sections" id="rolePoolSections">
          <!-- sections populated by JS -->
        </div>
      </div>

      <!-- Role assignments (moved here so kill buttons appear next to roles) -->
      <div id="playerRolesSection" style="display: none; margin-top: 1rem;">
        <div class="roles-header">🎭 Player Role Assignments:</div>
        <div id="playerRolesList" class="player-roles"></div>
      </div>

      <button class="btn" onclick="addRole()" id="addRoleBtn">Add Role</button>
      <div class="total-count">Total Roles: <span id="totalRoles">0</span></div>
    </div>

    <div class="panel">
      <div>Players Joined <span class="count" id="playerCount">0</span></div>
      <ul id="playerList"></ul>
      <div class="small time" id="time">Last updated: —</div>
    </div>

    <div class="panel">
      <button class="btn btn-success" onclick="assignRoles()" id="assignBtn" disabled>Assign Roles</button>
      <button class="btn" onclick="restartGame()" id="restartBtn">Restart Game</button>
      <button class="btn btn-danger" onclick="resetGame()" id="resetBtn">Reset Game</button>
      <button class="btn" id="toggleChatBtn" onclick="toggleHostChat()">Lobby Chat</button>
    </div>

    <!-- Global mute toggle (floating) -->
    <div style="position:fixed;right:14px;bottom:64px;z-index:9999">
      <!-- Icon-only site mute toggle: accessible button with visually-hidden label -->
      <button id="hostMuteBtn" aria-pressed="false" aria-label="Mute site" title="Mute site"
        style="background:#fff;padding:8px;border-radius:999px;box-shadow:0 2px 6px rgba(0,0,0,.15);border:none;display:inline-flex;align-items:center;justify-content:center;">
        <!-- speaker icon -->
        <svg id="hostMuteIcon" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#0f172a" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
          <path d="M11 5L6 9H3v6h3l5 4V5z" />
          <path id="hostMuteWave" d="M19 9a4 4 0 0 1 0 6" />
        </svg>
      </button>
    </div>

    <div class="panel" id="gameControls">
      <h3>Moderator Controls</h3>
      <style>
        /* Simple slider-style switch */
        .switch {
          position: relative;
          display: inline-block;
          width: 56px;
          height: 28px;
        }
        .switch input { display: none; }
        .slider {
          position: absolute;
          cursor: pointer;
          top: 0; left: 0; right: 0; bottom: 0;
          background-color: #334155;
          transition: background-color 200ms ease;
          border-radius: 999px;
          border: 1px solid rgba(255,255,255,0.03);
        }
        .slider:before {
          content: '';
          position: absolute;
          height: 22px;
          width: 22px;
          left: 3px;
          top: 3px;
          background-color: white;
          border-radius: 50%;
          transition: transform 160ms cubic-bezier(.2,.9,.2,1);
        }
        .switch input:checked + .slider { background-color: #059669; }
        .switch input:checked + .slider:before { transform: translateX(28px); }
        .interactive-label { display:inline-flex; align-items:center; gap:0.5rem; }
      </style>
      <div style="margin-bottom:0.75rem; display:flex; align-items:center; gap:0.75rem;">
        <label style="font-weight:700;">Interactive mode</label>
        <label class="interactive-label">
          <span class="switch">
            <input type="checkbox" id="interactiveModeToggle" checked />
            <span class="slider" aria-hidden="true"></span>
          </span>
          <span class="small" id="interactiveModeLabel">On</span>
        </label>
        <div class="small" style="color:#94a3b8;">When off, players won't see night/day phase info and moderator UI is minimized.</div>
      </div>
      <div style="display:flex; gap:0.5rem; flex-wrap:wrap; align-items:center;">
  <button class="btn btn-success" id="startGameBtn" onclick="startGame()">Start Game</button>
  <button class="btn" id="startNightBtn" onclick="startNight()">Start Night</button>
  <button class="btn" id="startDayBtn" onclick="startDay()">Start Day</button>
  <button class="btn" id="advanceNightBtn" onclick="advanceNightStep()">Advance Night Step</button>
  <button class="btn btn-danger" id="lynchBtn" onclick="lynchPlayer()">Lynch (End of Day)</button>
      </div>
      <div style="margin-top:0.75rem; display:flex; gap:1rem; flex-wrap:wrap; align-items:flex-start;">
        <div style="flex:1; min-width:200px;">
          <div class="small">Phase</div>
          <div style="font-weight:800; font-size:1.05rem;"> <span id="currentPhase">Lobby</span></div>
          <div class="small" style="margin-top:0.5rem;">Night step</div>
          <div style="font-weight:700;"> <span id="nightStepDisplay">—</span></div>
          <div class="small" style="margin-top:0.5rem;">Mafia chooser</div>
          <div id="mafiaChooser" style="font-weight:700;">—</div>
        </div>

        <div style="flex:1; min-width:200px;">
          <div class="small">Last night killed</div>
          <div style="font-weight:700;"> <span id="lastKilled">—</span></div>
          <div class="small" style="margin-top:0.5rem;">Last night muted</div>
          <div style="font-weight:700;"> <span id="lastMuted">—</span></div>
          <div class="small" style="margin-top:0.5rem;">Winner</div>
          <div style="font-weight:700;"> <span id="gameWinner">—</span></div>
        </div>

        <div style="flex:1; min-width:220px;">
          <div class="small">Pending night actions</div>
          <div id="pendingActions" style="font-weight:700; margin-bottom:0.4rem;">—</div>
          <div class="small">Last night events</div>
          <div id="lastNightEventsList" style="background:#071024; padding:0.5rem; border-radius:8px; border:1px solid rgba(255,255,255,0.03); max-height:130px; overflow:auto;">—</div>
        </div>
      </div>
    </div>

    <!-- Voting Dashboard: separate panel for voting UI -->
    <div class="panel" id="votingDashboard" style="display:block;">
      <h3>Voting Dashboard</h3>
      <div style="display:flex; gap:1rem; flex-wrap:wrap; align-items:flex-start;">
        <div style="flex:1; min-width:220px;">
          <div class="small">Voting status</div>
          <div id="votingStatus" style="font-weight:800; font-size:1rem;">—</div>
          <div class="small" style="margin-top:0.5rem;">Current voter</div>
          <div id="votingCurrent" style="font-weight:700; font-size:1.05rem;">—</div>
              <div style="margin-top:0.75rem; display:flex; gap:0.5rem; align-items:center;">
                <button class="btn btn-primary" id="startVotingBtn" onclick="startVoting()">Start Voting</button>
                <button class="btn" id="resetVotingBtn" style="background:#374151; color:#e2e8f0;" onclick="resetVoting()">Reset Voting</button>
              </div>
        </div>

        <div style="flex:1.2; min-width:260px;">
          <div class="small">Vote tally (players with >=1 vote)</div>
          <div id="votingTally" style="background:#071024; padding:0.75rem; border-radius:8px; border:1px solid rgba(255,255,255,0.03); max-height:220px; overflow:auto;">—</div>
        </div>

        <div style="flex:1.4; min-width:260px;">
          <div class="small">Vote log (running)</div>
          <div id="votingLog" style="background:#071024; padding:0.75rem; border-radius:8px; border:1px solid rgba(255,255,255,0.03); max-height:220px; overflow:auto;">—</div>
        </div>
      </div>
    </div>

    <!-- Winner banner (hidden until game over) -->
    <div id="winnerBanner" style="display:none; margin-top:1rem; padding:1rem; border-radius:8px; text-align:center; font-weight:800; font-size:1.1rem;
                 background:#071024; border:1px solid rgba(255,255,255,0.03);">
      <span id="winnerText">Winner: —</span>
    </div>

    <!-- Toast notification for brief messages before redirects (host) -->
    <div id="toast" style="display:none; position: fixed; left: 50%; transform: translateX(-50%); bottom: 12vh; background: rgba(0,0,0,0.7); color: #fff; padding: 0.8rem 1.2rem; border-radius: 8px; font-weight: 700; box-shadow: 0 6px 20px rgba(0,0,0,0.5); z-index: 1100;">
      <span id="toastMessage">Message</span>
    </div>

    <!-- Lynch Modal -->
    <div id="lynchModal" style="display:none; position:fixed; left:0; top:0; width:100%; height:100%; background:rgba(0,0,0,0.6); align-items:center; justify-content:center; z-index:1200;">
      <div style="background:#0b1220; padding:1rem 1.25rem; border-radius:10px; width:320px; border:1px solid rgba(255,255,255,0.04);">
        <h3 style="margin:0 0 0.5rem 0; color:#f1f5f9;">Submit Lynch</h3>
        <div style="margin-bottom:0.5rem;">
          <label class="small">Player to lynch</label>
          <select id="lynchTarget" style="width:100%; padding:0.5rem; margin-top:0.25rem; border-radius:6px; background:#111827; color:#f1f5f9; border:1px solid #334155;"></select>
        </div>
        <!-- Suicide bomber target removed: server still accepts no suicide_target, UI no longer exposes this option -->
        <div style="display:flex; gap:0.5rem; justify-content:flex-end;">
          <button class="btn" onclick="closeLynchModal()">Cancel</button>
          <button class="btn btn-danger" onclick="submitLynch()">Submit</button>
        </div>
      </div>
    </div>

    <p class="small">Share the join link: <code id="joinLink"></code>
      <button id="copyJoinBtn" class="btn btn-secondary btn-copy" onclick="copyJoinLink()">Copy</button>
      <span id="copyStatus" class="copy-status" aria-live="polite"></span>
    </p>
  </div>

  <!-- Host Chat Panel (hidden by default) -->
  <div id="hostChatPanel" class="panel" style="display:none; max-width:900px; margin: 0 auto;">
    <h3>Lobby Chat <small class="small">(Host view)</small></h3>
    <div id="hostChatMessages" style="height:260px; overflow:auto; background:#0b1220; padding:0.75rem; border-radius:8px; border:1px solid rgba(255,255,255,0.03);"></div>
    <div style="display:flex; gap:0.5rem; margin-top:0.75rem;">
      <input id="hostChatInput" placeholder="Type a message as Host..." style="flex:1; padding:0.6rem; border-radius:8px; border:1px solid #334155; background:#041027; color:#e2e8f0;" />
      <button class="btn btn-success" onclick="sendHostChat()">Send</button>
      <button class="btn" onclick="toggleHostChat()">Close</button>
    </div>
  </div>

  <div class="footer">
    Created by Scissors. Powered by Sunisha and Diet Coke
  </div>

  <script>
    // interactive mode state (mirrors server-side value)
    let interactiveMode = true;

    async function setInteractiveOnServer(val) {
      try {
        const body = `interactive=${encodeURIComponent(val ? 'true' : 'false')}`;
        const resp = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/set-interactive`, { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded' }, body });
        const d = await resp.json();
        if (d && typeof d.interactive_mode !== 'undefined') {
          interactiveMode = !!d.interactive_mode;
          updateInteractiveUI();
        }
      } catch (e) { console.warn('Failed to persist interactive mode', e); }
    }

    function updateInteractiveUI() {
      const toggle = document.getElementById('interactiveModeToggle');
      const label = document.getElementById('interactiveModeLabel');
      if (toggle) toggle.checked = !!interactiveMode;
      if (label) label.textContent = interactiveMode ? 'On' : 'Off';
      // When interactive mode is off, hide/disable moderator-only controls (Start Night, Start Day, Advance Night, Lynch)
      // Keep Start Game and voting controls available at all times.
      const startGameBtn = document.getElementById('startGameBtn');
      const startNightBtn = document.getElementById('startNightBtn');
      const startDayBtn = document.getElementById('startDayBtn');
      const advanceNightBtn = document.getElementById('advanceNightBtn');
      const lynchBtn = document.getElementById('lynchBtn');

      if (!interactiveMode) {
        // hide the moderator-only buttons
        if (startNightBtn) { startNightBtn.style.display = 'none'; startNightBtn.disabled = true; }
        if (startDayBtn) { startDayBtn.style.display = 'none'; startDayBtn.disabled = true; }
        if (advanceNightBtn) { advanceNightBtn.style.display = 'none'; advanceNightBtn.disabled = true; }
        if (lynchBtn) { lynchBtn.style.display = 'none'; lynchBtn.disabled = true; }

        // clear phase info to avoid showing stale values
        try {
          const phaseEl = document.getElementById('currentPhase'); if (phaseEl) phaseEl.textContent = '—';
          const nightStepEl = document.getElementById('nightStepDisplay'); if (nightStepEl) nightStepEl.textContent = '—';
          const mafiaChooserEl = document.getElementById('mafiaChooser'); if (mafiaChooserEl) mafiaChooserEl.textContent = '—';
          const pendingEl = document.getElementById('pendingActions'); if (pendingEl) pendingEl.textContent = '—';
          const lastEventsEl = document.getElementById('lastNightEventsList'); if (lastEventsEl) lastEventsEl.textContent = '—';
        } catch (e) {}
      } else {
        // restore moderator-only buttons
        if (startNightBtn) { startNightBtn.style.display = ''; startNightBtn.disabled = false; }
        if (startDayBtn) { startDayBtn.style.display = ''; startDayBtn.disabled = false; }
        if (advanceNightBtn) { advanceNightBtn.style.display = ''; advanceNightBtn.disabled = false; }
        if (lynchBtn) { lynchBtn.style.display = ''; lynchBtn.disabled = false; }
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      const t = document.getElementById('interactiveModeToggle');
      if (t) {
        t.addEventListener('change', (e) => {
          interactiveMode = !!e.target.checked;
          setInteractiveOnServer(interactiveMode);
          updateInteractiveUI();
        });
        // keyboard accessibility: allow space to toggle when focused
        t.addEventListener('keydown', (ev) => {
          if (ev.key === ' ' || ev.key === 'Enter') {
            ev.preventDefault();
            t.checked = !t.checked;
            t.dispatchEvent(new Event('change'));
          }
        });
      }
      // Initialize interactiveMode from server so checkbox reflects persisted state and UI is correct
      (async function(){
        try {
          const resp = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/players`, { cache: 'no-store' });
          if (!resp.ok) return;
          const d = await resp.json();
          if (typeof d.interactive_mode !== 'undefined') {
            interactiveMode = !!d.interactive_mode;
            updateInteractiveUI();
          }
        } catch (e) { /* ignore */ }
      })();
    });
    const playerListEl = document.getElementById('playerList');
    const playerCountEl = document.getElementById('playerCount');
    const timeEl = document.getElementById('time');
    const joinLinkEl = document.getElementById('joinLink');
    const rolesContainer = document.getElementById('rolesContainer');
    const totalRolesEl = document.getElementById('totalRoles');
    const assignBtn = document.getElementById('assignBtn');
    const addRoleBtn = document.getElementById('addRoleBtn');
    const resetBtn = document.getElementById('resetBtn');
    const statusPanel = document.getElementById('statusPanel');
    const statusText = document.getElementById('statusText');
    const gameStatus = document.getElementById('gameStatus');
    const playerRolesSection = document.getElementById('playerRolesSection');
    const playerRolesList = document.getElementById('playerRolesList');
    const gamePasswordEl = document.getElementById('gamePassword');
    const passwordStatusEl = document.getElementById('passwordStatus');

    const ROOM_NAME = '{{ room_name | e }}';
    joinLinkEl.textContent = `${location.protocol}//${location.host}/room/${encodeURIComponent(ROOM_NAME)}`;

    let roles = [];
    let gameStarted = false;
  // Snapshot of last assignments to avoid re-rendering/animating on every poll
  let lastAssignmentsSnapshot = null;

    function escapeHtml(str) {
      const p = document.createElement('p');
      p.innerText = str;
      return p.innerHTML;
    }

    function setPassword() {
      const password = gamePasswordEl.value;
      
      fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/set-player-password`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: `password=${encodeURIComponent(password)}`
      })
      .then(response => response.json())
      .then(data => {
        if (data.success) {
          if (data.password_set) {
            passwordStatusEl.textContent = 'Password set successfully';
            passwordStatusEl.style.color = '#34d399';
          } else {
            passwordStatusEl.textContent = 'Password removed - anyone can join';
            passwordStatusEl.style.color = '#94a3b8';
          }
        }
      })
      .catch(error => {
        console.error('Error setting password:', error);
        passwordStatusEl.textContent = 'Error setting password';
        passwordStatusEl.style.color = '#f87171';
      });
    }

    async function killPlayer(playerName) {
      if (!confirm(`Are you sure you want to eliminate ${playerName}?`)) {
        return;
      }

      try {
        const resp = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/kill-player`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: `player_name=${encodeURIComponent(playerName)}`
        });
        
        const data = await resp.json();
        
        if (data.success) {
          // Refresh to show updated player status
          setTimeout(refresh, 100);
        } else {
          alert('Error eliminating player: ' + data.error);
        }
      } catch (e) {
        console.error('Error eliminating player:', e);
        alert('Error eliminating player: ' + e.message);
      }
    }

    // Moderator actions: start game / night / day / lynch
    async function startGame() {
      try {
        const resp = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/start-game`, { method: 'POST' });
        const d = await resp.json();
        if (d.success) {
          alert('Game started. Night phase initialized.');
          setTimeout(refresh, 200);
        } else {
          alert('Start game failed: ' + (d.error || 'unknown'));
        }
      } catch (e) {
        console.error('startGame error', e);
        alert('Error starting game');
      }
    }

    async function startNight() {
      try {
        const resp = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/start-night`, { method: 'POST' });
        const d = await resp.json();
        if (d.success) {
          alert('Night started. Players with night actions may act now.');
          setTimeout(refresh, 200);
        } else {
          alert('Start night failed: ' + (d.error || 'unknown'));
        }
      } catch (e) {
        console.error('startNight error', e);
        alert('Error starting night');
      }
    }

    async function startVoting() {
      if (!confirm('Start a sequential voting round where players are prompted one-by-one to vote?')) return;
      try {
        const resp = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/start-voting`, { method: 'POST' });
        const d = await resp.json();
        if (d && d.success) {
          showToast('Voting started', 1200);
          setTimeout(refresh, 200);
        } else {
          alert('Start voting failed: ' + (d.error || 'unknown'));
        }
      } catch (e) {
        console.error('startVoting error', e);
        alert('Error starting voting');
      }
    }

    async function resetVoting() {
      if (!confirm('Reset voting for all players? This will clear the current voting dashboard.')) return;
      try {
        const resp = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/reset-voting`, { method: 'POST' });
        const d = await resp.json();
        if (d && d.success) {
          showToast('Voting reset', 900);
          // refresh host UI; SSE will also push the cleared state
          setTimeout(refresh, 150);
        } else {
          alert('Reset voting failed: ' + (d.error || 'unknown'));
        }
      } catch (e) {
        console.error('resetVoting error', e);
        alert('Error resetting voting');
      }
    }

    async function startDay() {
      try {
        const resp = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/start-day`, { method: 'POST' });
        const d = await resp.json();
        if (d.success) {
          alert('Day started. Killed players revealed.');
          setTimeout(refresh, 200);
        } else {
          alert('Start day failed: ' + (d.error || 'unknown'));
        }
      } catch (e) {
        console.error('startDay error', e);
        alert('Error starting day');
      }
    }

    async function lynchPlayer() {
      openLynchModal();
    }

    function openLynchModal() {
      // populate select with alive players
      const targetSel = document.getElementById('lynchTarget');
      targetSel.innerHTML = '';
      // gather from current player list
      const opts = Array.from(document.querySelectorAll('#playerList li')).map(li => {
        const name = li.querySelector('.player-name').textContent.replace(' 💀','').trim();
        return { name, eliminated: li.classList.contains('eliminated') };
      }).filter(p => !p.eliminated);

      for (const p of opts) {
        const o = document.createElement('option'); o.value = p.name; o.textContent = p.name; targetSel.appendChild(o);
      }

      document.getElementById('lynchModal').style.display = 'flex';
    }

    function closeLynchModal() {
      document.getElementById('lynchModal').style.display = 'none';
    }

    async function submitLynch() {
      const name = document.getElementById('lynchTarget').value;
      if (!name) { alert('Select a player to lynch'); return; }
      try {
        const body = `player_name=${encodeURIComponent(name)}`;
        const resp = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/lynch`, { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded' }, body });
        // Be tolerant of non-JSON or HTML responses (some edge cases return text/html).
        // Try to parse JSON first, fall back to raw text.
        let text = '';
        try {
          text = await resp.text();
        } catch (e) {
          console.warn('Could not read lynch response body', e);
        }

        let d = null;
        try { d = text ? JSON.parse(text) : null; } catch (e) { d = null; }

        if (!resp.ok) {
          // server returned an error status
          const errMsg = (d && d.error) ? d.error : (text || `HTTP ${resp.status}`);
          alert('Lynch failed: ' + errMsg);
          return;
        }

        // If JSON present and indicates success, show details.
        if (d && d.success) {
          showToast(`Lynched ${d.lynched}` + (d.suicide_killed ? ` — suicide killed ${d.suicide_killed}` : ''), 2200);
          closeLynchModal();
          setTimeout(refresh, 200);
          return;
        }

        // If we got a 200 OK but couldn't parse JSON, assume the operation succeeded on server
        // (this is defensive: the server sometimes returns non-JSON in edge cases). Close modal and refresh.
        showToast(`Lynched ${name}`, 1800);
        closeLynchModal();
        setTimeout(refresh, 200);
      } catch (e) {
        console.error('lynch submit error', e);
        alert('Error submitting lynch: ' + (e && e.message ? e.message : String(e)));
      }
    }

    function addRole() {
      const roleDiv = document.createElement('div');
      roleDiv.className = 'role-input';
      roleDiv.innerHTML = `
        <input type="text" placeholder="Role name (e.g., Mafia, Villager)" class="role-name">
        <select class="role-faction">
          <option value="">(auto)</option>
          <option value="Mafia">Mafia</option>
          <option value="Villagers">Villagers</option>
          <option value="Neutral">Neutral</option>
        </select>
        <input type="number" min="1" value="1" class="role-count">
        <button class="btn remove-btn" onclick="removeRole(this)">Remove</button>
      `;
      rolesContainer.appendChild(roleDiv);
      updateTotalRoles();
    }

    // Populate editable role inputs from a server-provided roles list
    function populateRolesFromServer(serverRoles) {
      // serverRoles is expected to be an array of {name, count, faction}
      // Clear existing inputs
      rolesContainer.innerHTML = '';
      if (!serverRoles || !serverRoles.length) {
        // No server-provided roles: leave the container empty. Host can press "Add Role" to add inputs.
        return;
      }

      serverRoles.forEach(r => {
        const roleDiv = document.createElement('div');
        roleDiv.className = 'role-input';
        const name = r.name || '';
        const count = r.count || 1;
        const faction = r.faction || '';
        roleDiv.innerHTML = `
          <input type="text" placeholder="Role name (e.g., Mafia, Villager)" class="role-name" value="${escapeHtml(name)}">
          <select class="role-faction">
            <option value="">(auto)</option>
            <option value="Mafia">Mafia</option>
            <option value="Villagers">Villagers</option>
            <option value="Neutral">Neutral</option>
          </select>
          <input type="number" min="1" value="${count}" class="role-count">
          <button class="btn remove-btn" onclick="removeRole(this)">Remove</button>
        `;
        rolesContainer.appendChild(roleDiv);
        // set faction select after insertion (to avoid HTML escaping issues)
        const sel = roleDiv.querySelector('.role-faction');
        if (sel) sel.value = faction || '';
      });

      updateTotalRoles();
    }

    function removeRole(btn) {
      btn.parentElement.remove();
      updateTotalRoles();
    }

    function updateTotalRoles() {
      const roleCounts = document.querySelectorAll('.role-count');
      let total = 0;
      roleCounts.forEach(input => {
        total += parseInt(input.value) || 0;
      });
      totalRolesEl.textContent = total;
      return total;
    }

    function collectRoles() {
      const roleInputs = document.querySelectorAll('.role-input');
      const collectedRoles = [];
      
      roleInputs.forEach(roleDiv => {
        const nameInput = roleDiv.querySelector('.role-name');
        const factionSelect = roleDiv.querySelector('.role-faction');
        const countInput = roleDiv.querySelector('.role-count');
        const name = nameInput.value.trim();
        const count = parseInt(countInput.value) || 0;
        const faction = factionSelect ? factionSelect.value : '';
        
        if (name && count > 0) {
          collectedRoles.push({ name, count, faction });
        }
      });
      
      return collectedRoles;
    }

    // fetch factions map from server for auto-detect
    let _factionsMap = {};
    async function loadFactionsMap(){
      try{
        const resp = await fetch('/api/factions');
        const data = await resp.json();
        if (data.factions) _factionsMap = data.factions;
      }catch(e){ }
    }

    // auto-detect faction when typing role names
    document.addEventListener('input', (e) => {
      if (!e.target.matches('.role-name')) return;
      const input = e.target;
      const val = input.value.trim().toLowerCase();
      const roleDiv = input.closest('.role-input');
      const sel = roleDiv && roleDiv.querySelector('.role-faction');
      if (!sel) return;
      if (!val){ sel.value = ''; return; }
      // exact match first
      if (_factionsMap[val]) { sel.value = _factionsMap[val]; return; }
      // partial match
      for(const k in _factionsMap){ if (val.includes(k)){ sel.value = _factionsMap[k]; return; } }
      // no match: leave as auto
      sel.value = '';
    });

    // load factions map on start
    loadFactionsMap();

    // Display assignments grouped by faction, then by role
    function displayPlayerRoles(assignments, eliminatedPlayers = []) {
      if (!assignments || Object.keys(assignments).length === 0) {
        playerRolesSection.style.display = 'none';
        return;
      }

      // Build role -> players mapping
      const roleMap = {};
      Object.keys(assignments).forEach(player => {
        const role = assignments[player] || 'Unassigned';
        if (!roleMap[role]) roleMap[role] = [];
        roleMap[role].push(player);
      });

      playerRolesSection.style.display = 'block';
      playerRolesList.innerHTML = '';

      // helper: deterministic color per role name (returns hsl string)
      function roleColor(role) {
        let h = 0;
        for (let i = 0; i < role.length; i++) {
          h = (h * 31 + role.charCodeAt(i)) % 360;
        }
        return `hsl(${h} 75% 55% / 1)`;
      }

      // Build a quick lookup from role name -> faction using server-provided roles when available
      const roleToFaction = {};
      try {
        const rr = window.__roomRoles || [];
        for (const r of rr) {
          if (r && r.name) roleToFaction[r.name] = r.faction || '';
        }
      } catch (e) { /* ignore */ }

      // Group roles under their factions
      const factionMap = {};
      Object.keys(roleMap).forEach(roleName => {
        const faction = roleToFaction[roleName] || '';
        if (!factionMap[faction]) factionMap[faction] = {};
        factionMap[faction][roleName] = roleMap[roleName];
      });

      // Render faction sections in a preferred order
      const preferredOrder = ['Mafia', 'Villagers', 'Neutral', ''];
      const factionsOrdered = [];
      for (const pf of preferredOrder) if (pf in factionMap) factionsOrdered.push(pf);
      Object.keys(factionMap).sort().forEach(f => { if (!factionsOrdered.includes(f)) factionsOrdered.push(f); });

      const sectionCards = [];

      for (const factionName of factionsOrdered) {
        const rolesForFaction = factionMap[factionName] || {};

        const section = document.createElement('div');
        section.className = 'faction-section panel';

        const sectHeader = document.createElement('div');
        sectHeader.className = 'roles-header';
        const displayFaction = factionName || 'Unspecified';
        const countPlayers = Object.values(rolesForFaction).reduce((acc, arr) => acc + (arr ? arr.length : 0), 0);
        sectHeader.textContent = displayFaction + ' (' + countPlayers + ')';
        section.appendChild(sectHeader);

        const rolesWrap = document.createElement('div');
        rolesWrap.style.display = 'grid';
        rolesWrap.style.gridTemplateColumns = 'repeat(auto-fit, minmax(220px, 1fr))';
        rolesWrap.style.gap = '0.75rem';

        Object.keys(rolesForFaction).sort().forEach(roleName => {
          const card = document.createElement('div');
          card.className = 'role-card';

          const header = document.createElement('div');
          header.className = 'role-card-header';
          const accent = document.createElement('span');
          accent.className = 'role-accent';
          accent.style.background = roleColor(roleName);
          header.appendChild(accent);

          const title = document.createElement('div');
          title.className = 'role-card-title';
          title.textContent = roleName;
          header.appendChild(title);

          const count = document.createElement('div');
          count.className = 'role-card-count';
          count.textContent = `(${roleMap[roleName].length})`;
          header.appendChild(count);

          const rf = roleToFaction[roleName] || '';
          if (rf) {
            const fb = document.createElement('span');
            const cls = 'faction-' + rf.toLowerCase().replace(/[^a-z0-9]+/g, '') || 'unknown';
            fb.className = 'faction-badge ' + (cls || 'faction-unknown');
            fb.textContent = rf;
            header.appendChild(fb);
          }

          card.appendChild(header);

          const playersWrap = document.createElement('div');
          playersWrap.style.display = 'flex';
          playersWrap.style.flexWrap = 'wrap';
          playersWrap.style.gap = '0.5rem';

          rolesForFaction[roleName].sort().forEach(playerName => {
            const isEliminated = eliminatedPlayers.includes(playerName);
            const pill = document.createElement('div');
            pill.className = 'player-pill' + (isEliminated ? ' eliminated' : '');

            const nameSpan = document.createElement('span');
            nameSpan.textContent = playerName;
            // keep role-assignment pill names white/default in the host UI
            pill.appendChild(nameSpan);

            if (isEliminated) {
              const skull = document.createElement('span');
              skull.className = 'eliminated-icon';
              skull.textContent = '💀';
              pill.appendChild(skull);
            }

            const actions = document.createElement('span');
            actions.className = 'pill-actions';
            const btn = document.createElement('button');
            btn.className = 'kill-btn';
            btn.textContent = isEliminated ? 'Eliminated' : 'Kill';
            if (isEliminated) btn.disabled = true;
            btn.onclick = () => killPlayer(playerName);
            actions.appendChild(btn);

            pill.appendChild(actions);
            playersWrap.appendChild(pill);
          });

          card.appendChild(playersWrap);
          rolesWrap.appendChild(card);
          sectionCards.push(card);
        });

        section.appendChild(rolesWrap);
        playerRolesList.appendChild(section);
      }

      requestAnimationFrame(() => {
        sectionCards.forEach(card => {
          card.classList.add('show');
          card.querySelectorAll('.player-pill').forEach((p, i) => {
            setTimeout(() => p.classList.add('show'), i * 30);
          });
        });
      });
    }

    async function syncRoles() {
      const currentRoles = collectRoles();
      
      try {
        // Don't reset if game already started
        const statusResp = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/players`);
        const statusData = await statusResp.json();
        if (statusData.game_started) {
          return;
        }
        
        // Clear server roles only (not players!)
        await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/reset-roles`, { method: 'POST' });
        
        // Add each role
        for (const role of currentRoles) {
          const resp = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/roles`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: `role_name=${encodeURIComponent(role.name)}&role_count=${role.count}&role_faction=${encodeURIComponent(role.faction || '')}`
          });
          if (!resp.ok) {
            console.error('Failed to add role:', role);
          }
        }
      } catch (e) {
        console.error('Error syncing roles:', e);
        throw e;
      }
    }

    async function assignRoles() {
      // First sync roles to server
      await syncRoles();
      
      // Small delay to ensure sync completes
      await new Promise(resolve => setTimeout(resolve, 100));
      
      try {
        const resp = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/assign`, { method: 'POST' });
        const data = await resp.json();
        
        if (data.success) {
          gameStarted = true;
          addRoleBtn.disabled = true;
          assignBtn.disabled = true;
          document.querySelectorAll('.role-name, .role-count, .remove-btn').forEach(el => el.disabled = true);
          gameStatus.textContent = 'Started';
          statusText.textContent = 'Game started! Roles have been assigned.';
          statusPanel.className = 'status ready';
          
          // Refresh to show the role assignments
          setTimeout(refresh, 500);
        } else {
          alert('Error: ' + data.error);
          console.error('Assignment error:', data);
        }
      } catch (e) {
        console.error('Error assigning roles:', e);
        alert('Error assigning roles: ' + e.message);
      }
    }

    async function resetGame() {
      if (confirm('Are you sure you want to reset the game? This will clear all players and roles.')) {
        try {
          await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/reset`, { method: 'POST' });
          location.reload();
        } catch (e) {
          alert('Error resetting game');
        }
      }
    }

    async function restartGame() {
      if (!confirm('Restart the game? This will clear current assignments and eliminated players but keep players and roles.')) return;
      try {
        const resp = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/restart`, { method: 'POST' });
        const data = await resp.json();
        if (data.success) {
          // Clear UI assignment snapshot and refresh to show lobby state
          lastAssignmentsSnapshot = null;
          // Refresh to get the current server roles and player list
          await refresh();
          // After refresh, if server provided roles, populate editable inputs so host can tweak them
          try {
            const r = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/players`, { cache: 'no-store' });
            const d = await r.json();
            if (d.roles && Array.isArray(d.roles) && d.roles.length) {
              populateRolesFromServer(d.roles);
            }
          } catch (e) {
            console.warn('Could not fetch server roles to populate inputs after restart', e);
          }

          alert('Game restarted — roles preserved and pre-filled for editing. Players remain in lobby.');
        } else {
          alert('Error restarting game: ' + (data.error || 'unknown'));
        }
      } catch (e) {
        console.error('Error restarting game', e);
        alert('Error restarting game');
      }
    }

    async function refresh() {
      try {
        const resp = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/players`, { cache: 'no-store' });
        const data = await resp.json();
        // store server-side roles info (if provided elsewhere)
        if (data.roles) window.__roomRoles = data.roles;
        
        playerCountEl.textContent = data.count;
        // expose per-player chat colors for use elsewhere in the host UI
        window.__chatColors = data.chat_colors || {};
        
        playerListEl.innerHTML = '';
        for (const playerName of data.players) {
          const isEliminated = data.eliminated_players && data.eliminated_players.includes(playerName);
          const li = document.createElement('li');
          li.className = isEliminated ? 'eliminated' : '';
          
          const playerNameSpan = document.createElement('span');
          playerNameSpan.className = isEliminated ? 'player-name eliminated' : 'player-name';
          // keep player list names white/default in the host UI (colors are only shown in lobby chat)
          playerNameSpan.innerHTML = escapeHtml(playerName) + (isEliminated ? ' <span class="eliminated-icon">💀</span>' : '');
          
          li.appendChild(playerNameSpan);

          // Add Kick button (host-only action)
          const kickActions = document.createElement('span');
          kickActions.style.display = 'inline-flex';
          kickActions.style.alignItems = 'center';
          kickActions.style.gap = '0.5rem';

          const kickBtn = document.createElement('button');
          kickBtn.className = 'kill-btn';
          kickBtn.textContent = 'Kick';
          kickBtn.onclick = () => kickPlayerFromHost(playerName);
          kickActions.appendChild(kickBtn);

          li.appendChild(kickActions);
          playerListEl.appendChild(li);
        }
        
  // If server provides saved roles and the local inputs are still default/empty, prefill them
        try {
          const localRoleNames = Array.from(document.querySelectorAll('.role-name')).map(i => i.value.trim()).filter(Boolean);
          if (data.roles && Array.isArray(data.roles) && data.roles.length && (!localRoleNames.length || (localRoleNames.length === 1 && localRoleNames[0] === ''))) {
            populateRolesFromServer(data.roles);
          }
        } catch (e) { /* ignore */ }

        // Display role assignments if game has started
        if (data.game_started && data.assignments) {
          const snapshot = JSON.stringify({ assignments: data.assignments, eliminated: data.eliminated_players || [] });
          if (snapshot !== lastAssignmentsSnapshot) {
            // only re-render when assignments or eliminated players changed
            lastAssignmentsSnapshot = snapshot;
            displayPlayerRoles(data.assignments, data.eliminated_players || []);
          }
        } else {
          lastAssignmentsSnapshot = null;
          playerRolesSection.style.display = 'none';
        }
        
        // Get frontend total roles
        const frontendTotalRoles = updateTotalRoles();
        
        // Check if we can start based on frontend roles (not server roles)
        const canStart = data.count > 0 && frontendTotalRoles > 0 && data.count === frontendTotalRoles && !data.game_started;
        assignBtn.disabled = !canStart;
        
        if (data.game_started) {
          gameStarted = true;
          addRoleBtn.disabled = true;
          assignBtn.disabled = true;
          document.querySelectorAll('.role-name, .role-count, .remove-btn').forEach(el => el.disabled = true);
          gameStatus.textContent = 'Started';
          statusText.textContent = 'Game started! Roles have been assigned.';
          statusPanel.className = 'status ready';
        } else if (canStart) {
          statusText.textContent = `Ready to start! ${data.count} players joined, ${frontendTotalRoles} roles configured.`;
          statusPanel.className = 'status ready';
        } else {
          statusText.textContent = `Waiting... ${data.count}/${frontendTotalRoles} players joined.`;
          statusPanel.className = 'status waiting';
        }

        // Ensure host can add roles again when the game is not started (e.g., after a restart)
        try {
          addRoleBtn.disabled = !!data.game_started;
        } catch (e) { /* ignore if button not present */ }
        
        // Update password status
        if (data.password_set) {
          passwordStatusEl.textContent = 'Password is set';
          passwordStatusEl.style.color = '#34d399';
        } else {
          passwordStatusEl.textContent = 'No password set - anyone can join';
          passwordStatusEl.style.color = '#94a3b8';
        }
        
        const now = new Date();
        timeEl.textContent = 'Last updated: ' + now.toLocaleTimeString();
      } catch (e) {
        timeEl.textContent = 'Last updated: (error contacting server)';
      }
      
      // fetch game-state to update host controls
      try {
        const gsResp = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/game-state`, { cache: 'no-store' });
        const gs = await gsResp.json();
        const phaseEl = document.getElementById('currentPhase');
        const lastKilledEl = document.getElementById('lastKilled');
        const lastMutedEl = document.getElementById('lastMuted');
        const winnerEl = document.getElementById('gameWinner');
  const nightStepDisplay = document.getElementById('nightStepDisplay');

        if (gs && phaseEl) phaseEl.textContent = gs.phase || '—';
        if (gs && nightStepDisplay) {
          if (gs.current_night_step) nightStepDisplay.textContent = (gs.current_night_step.name || '') + (gs.current_night_step.index != null ? ` (step ${gs.current_night_step.index})` : '');
          else nightStepDisplay.textContent = '—';
        }
        if (gs && gs.last_night_events) {
          lastKilledEl.textContent = (gs.last_night_events.killed && gs.last_night_events.killed.length) ? gs.last_night_events.killed.join(', ') : '—';
          lastMutedEl.textContent = gs.last_night_events.muted || '—';
        }
        if (gs && winnerEl) winnerEl.textContent = gs.winner || '—';
        // mafia chooser display (if present in night actions)
        try {
          const mafiaChooserEl = document.getElementById('mafiaChooser');
          const pendingEl = document.getElementById('pendingActions');
          const lastEventsEl = document.getElementById('lastNightEventsList');

          if (mafiaChooserEl) {
            let chooser = '—';
            if (gs && gs.current_night_actions && gs.current_night_actions.mafia_final_chooser) chooser = gs.current_night_actions.mafia_final_chooser;
            mafiaChooserEl.textContent = chooser;
          }

          if (pendingEl) {
            let pending = '—';
            if (gs && gs.current_night_actions) {
              // count acted keys (presence semantics: value !== undefined means acted)
              const actionKeys = Object.keys(gs.current_night_actions).filter(k => !k.endsWith('_chooser') && k !== 'mafia_final_chooser');
              const acted = actionKeys.filter(k => gs.current_night_actions[k] !== undefined && gs.current_night_actions[k] !== null).length;
              const totalPlayers = (gs && gs.players) ? gs.players.length : 0;
              pending = Math.max(0, totalPlayers - acted);
            }
            pendingEl.textContent = pending;
          }

          if (lastEventsEl) {
            if (gs && gs.last_night_events) {
              const parts = [];
              if (gs.last_night_events.killed && gs.last_night_events.killed.length) parts.push('<b>Killed:</b> ' + gs.last_night_events.killed.join(', '));
              if (gs.last_night_events.muted && gs.last_night_events.muted.length) parts.push('<b>Muted:</b> ' + gs.last_night_events.muted.join(', '));
              if (gs.last_night_events.framed && gs.last_night_events.framed.length) parts.push('<b>Framed:</b> ' + gs.last_night_events.framed.join(', '));
              if (gs.last_night_events.cop_results && Object.keys(gs.last_night_events.cop_results).length) {
                const cops = Object.keys(gs.last_night_events.cop_results).map(k => `${k}: ${gs.last_night_events.cop_results[k]}`);
                parts.push('<b>Cop:</b> ' + cops.join('; '));
              }
              lastEventsEl.innerHTML = parts.length ? parts.join('<br>') : '—';
            } else {
              lastEventsEl.textContent = '—';
            }
          }
        } catch (e) { /* ignore UI update errors */ }

        // Small animated banner for voting events (host)
        try {
          let votingBanner = document.getElementById('hostVotingBanner');
          if (!votingBanner) {
            votingBanner = document.createElement('div');
            votingBanner.id = 'hostVotingBanner';
            votingBanner.style.cssText = 'display:none; position:fixed; left:50%; transform:translateX(-50%) translateY(-8px); top:12px; z-index:1400; padding:0.8rem 1rem; border-radius:8px; font-weight:900; color:#fff; background:linear-gradient(90deg,#16a34a,#059669); box-shadow:0 10px 30px rgba(2,6,23,0.6); opacity:0; transition: transform 260ms cubic-bezier(.2,.9,.2,1), opacity 260ms ease;';
            votingBanner.textContent = 'Voting Started';
            document.body.appendChild(votingBanner);
          }
          // Show when voting active
          const wasActive = typeof persistentHostVotingSnapshot !== 'undefined' && persistentHostVotingSnapshot && persistentHostVotingSnapshot.active;
          const nowVoting = (gs && gs.voting && gs.voting.active) || (data && data.voting && data.voting.active);
          if (!wasActive && nowVoting) {
            votingBanner.style.display = 'block';
            setTimeout(() => { votingBanner.style.opacity = 1; votingBanner.style.transform = 'translateX(-50%) translateY(0)'; }, 10);
            setTimeout(() => { votingBanner.style.opacity = 0; votingBanner.style.transform = 'translateX(-50%) translateY(-8px)'; setTimeout(()=>{ votingBanner.style.display='none'; }, 260); }, 2400);
          }
        } catch(e) {}

        // Voting UI updates (from game-state or players payload)
        try {
          const votingCurrentEl = document.getElementById('votingCurrent');
          const votingTallyEl = document.getElementById('votingTally');
          const votingLogEl = document.getElementById('votingLog');
          const votingStatusEl = document.getElementById('votingStatus');
          // prefer game-state voting info if provided, else players response 'voting'
          let voting = (gs && gs.voting) ? gs.voting : null;
          if (!voting && typeof data !== 'undefined' && data && data.voting) voting = data.voting;

          // Use persistentHostVotingSnapshot if available so host UI persists after voting ends
          const snapshot = persistentHostVotingSnapshot || voting;
          if (snapshot && snapshot.reset) {
            // explicit reset: clear UI
            if (votingStatusEl) votingStatusEl.textContent = '—';
            if (votingCurrentEl) votingCurrentEl.textContent = '—';
            if (votingTallyEl) votingTallyEl.textContent = '—';
            if (votingLogEl) votingLogEl.textContent = '—';
          } else if (snapshot) {
            // keep the last-known data visible; show Active when running, Ended when finished
            if (snapshot.active) {
              if (votingStatusEl) votingStatusEl.textContent = 'Active';
              if (votingCurrentEl) votingCurrentEl.textContent = snapshot.current_voter || '—';
            } else {
              if (votingStatusEl) votingStatusEl.textContent = 'Ended';
              if (votingCurrentEl) votingCurrentEl.textContent = snapshot.current_voter || '—';
            }
            // render tally
            const t = snapshot.tally || {};
            const keys = Object.keys(t).filter(k => (t[k] || 0) > 0).sort((a,b)=> (t[b]||0)-(t[a]||0) || a.localeCompare(b));
            if (votingTallyEl) {
              if (keys.length) {
                votingTallyEl.innerHTML = keys.map(k => `<div style="display:flex; justify-content:space-between; margin-bottom:0.25rem;"><span>${escapeHtml(k)}</span><strong>${t[k]}</strong></div>`).join('');
              } else {
                votingTallyEl.textContent = '—';
              }
            }
            // render running log
            const log = snapshot.votes_log || [];
            if (votingLogEl) {
              if (log.length) {
                votingLogEl.innerHTML = log.map(l => `<div style="margin-bottom:0.25rem;">${escapeHtml(l.voter)} → <strong>${escapeHtml(l.choice)}</strong></div>`).join('');
              } else {
                votingLogEl.textContent = '—';
              }
            }
          } else {
            // no snapshot: hide/clear
            if (votingStatusEl) votingStatusEl.textContent = '—';
            if (votingCurrentEl) votingCurrentEl.textContent = '—';
            if (votingTallyEl) votingTallyEl.textContent = '—';
            if (votingLogEl) votingLogEl.textContent = '—';
          }
        } catch (e) { /* ignore voting UI errors */ }

        // enable/disable moderator buttons depending on phase and game state
        const startGameBtn = document.getElementById('startGameBtn');
        const startNightBtn = document.getElementById('startNightBtn');
        const startDayBtn = document.getElementById('startDayBtn');
        const lynchBtn = document.getElementById('lynchBtn');

        if (gs.game_over) {
          startGameBtn.disabled = true;
          startNightBtn.disabled = true;
          startDayBtn.disabled = true;
          lynchBtn.disabled = true;
          // show winner banner
          try {
            const wb = document.getElementById('winnerBanner');
            const wt = document.getElementById('winnerText');
            if (wb && wt) {
              wt.textContent = 'Winner: ' + (gs.winner || '—');
              wb.style.display = 'block';
              if ((gs.winner || '').toLowerCase() === 'mafia') wb.style.background = 'linear-gradient(90deg,#7f1d1d,#b91c1c)';
              else if ((gs.winner || '').toLowerCase() === 'villagers') wb.style.background = 'linear-gradient(90deg,#064e3b,#059669)';
              else wb.style.background = '#071024';
            }
          } catch (e) {}
        } else {
          // hide/reset winner banner when game is not over (e.g., after restart)
          try {
            const wb = document.getElementById('winnerBanner');
            const wt = document.getElementById('winnerText');
            if (wb && wt) {
              wb.style.display = 'none';
              wt.textContent = 'Winner: —';
            }
          } catch (e) {}

          // follow the original phase-based enable/disable logic
          if (gs.phase === 'lobby' || gs.phase === 'finished') {
            startGameBtn.disabled = false;
            startNightBtn.disabled = true;
            startDayBtn.disabled = true;
            lynchBtn.disabled = true;
          } else if (gs.phase === 'night') {
            startGameBtn.disabled = true;
            startNightBtn.disabled = true;
            startDayBtn.disabled = false; // host resolves night to day
            lynchBtn.disabled = true;
            // when in night, allow advancing steps manually
            document.getElementById('advanceNightBtn').disabled = false;
          } else if (gs.phase === 'day') {
            startGameBtn.disabled = true;
            startNightBtn.disabled = false; // start next night after lynch
            startDayBtn.disabled = true;
            lynchBtn.disabled = false; // host can submit lynch
          } else {
            // default safe state
            startGameBtn.disabled = false;
            startNightBtn.disabled = false;
            startDayBtn.disabled = false;
            lynchBtn.disabled = false;
          }
        }
      } catch (e) {
        // ignore game-state fetch errors
      }
    }

    async function advanceNightStep() {
      try {
        const resp = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/advance-night-step`, { method: 'POST' });
        const d = await resp.json();
        if (d.success) {
          showToast('Advanced night step', 900);
          setTimeout(refresh, 200);
        } else {
          alert('Advance night step failed: ' + (d.error || 'unknown'));
        }
      } catch (e) {
        console.error('advanceNightStep error', e);
        alert('Error advancing night step');
      }
    }

    // Host action: kick a player from the lobby (must be host-authenticated via cookie)
    async function kickPlayerFromHost(playerName) {
      if (!confirm(`Kick ${playerName} from the lobby? They will need to rejoin.`)) return;
      try {
        const resp = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/kick-player`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: `player_name=${encodeURIComponent(playerName)}`
        });
        const data = await resp.json();
        if (data.success) {
          // refresh to update UI
          setTimeout(refresh, 150);
        } else {
          alert('Kick failed: ' + (data.error || 'unknown'));
        }
      } catch (e) {
        console.error('Kick error', e);
        alert('Error kicking player: ' + e.message);
      }
    }

    // Add event listeners for role count changes
    document.addEventListener('input', (e) => {
      if (e.target.classList.contains('role-count') || e.target.classList.contains('role-name')) {
        updateTotalRoles();
        // Trigger a refresh to update button state
        setTimeout(refresh, 100);
      }
    });

  // No initial role added automatically. Host may click "Add Role" to create inputs.

    // --- Role pool logic ---
    // Fetch role descriptions and render pool segmented by faction
    async function loadRolePool() {
      try {
        const resp = await fetch('/role_descriptions.json', { cache: 'no-store' });
        const roles = await resp.json();

        // Try to get faction mapping from previously loaded map or fallback to /api/factions
        let factionsMap = _factionsMap || {};
        if (!factionsMap || Object.keys(factionsMap).length === 0) {
          try {
            const r = await fetch('/api/factions');
            const d = await r.json();
            if (d.factions) factionsMap = d.factions;
          } catch (e) { /* ignore */ }
        }

        // Build an inverted map: factionName -> [roleNames]
        const byFaction = {};
        for (const [roleName, desc] of Object.entries(roles)) {
          const key = (factionsMap[roleName.toLowerCase()] || '') || '';
          if (!byFaction[key]) byFaction[key] = [];
          byFaction[key].push({ name: roleName, desc });
        }

        // Preferred order
        const preferredOrder = ['Mafia', 'Villagers', 'Neutral', ''];
        const sectionsEl = document.getElementById('rolePoolSections');
        sectionsEl.innerHTML = '';

        const allFactions = new Set([...Object.keys(byFaction)]);
        const ordered = [];
        for (const pf of preferredOrder) if (allFactions.has(pf)) { ordered.push(pf); allFactions.delete(pf); }
        for (const f of Array.from(allFactions).sort()) ordered.push(f);

        for (const faction of ordered) {
          const sect = document.createElement('div');
          sect.className = 'role-pool-section';
          const h4 = document.createElement('h4');
          h4.textContent = faction || 'Unspecified';
          sect.appendChild(h4);

          const wrap = document.createElement('div');
          wrap.className = 'role-pool-buttons';

          (byFaction[faction] || []).sort((a,b)=>a.name.localeCompare(b.name)).forEach(r => {
            const btn = document.createElement('button');
            btn.className = 'role-pool-btn';
            const cls = 'faction-' + ((faction||'unknown').toLowerCase().replace(/[^a-z0-9]+/g, ''));
            btn.classList.add(cls);
            btn.title = r.desc || '';
            btn.innerHTML = `<span class="role-dot" style="background:${dotColorForRole(r.name)}"></span><span>${escapeHtml(r.name)}</span>`;
            btn.onclick = () => onRolePoolClick(r.name, faction);
            wrap.appendChild(btn);
          });

          sect.appendChild(wrap);
          sectionsEl.appendChild(sect);
        }
      } catch (e) {
        console.error('Failed to load role pool', e);
      }
    }

    // Generate a small deterministic color for the role dot
    function dotColorForRole(role) {
      let h = 0;
      for (let i = 0; i < role.length; i++) h = (h * 31 + role.charCodeAt(i)) % 360;
      return `hsl(${h} 70% 55% / 1)`;
    }

    // When host clicks a role in the pool: add it to inputs or increment existing count
    function onRolePoolClick(roleName, factionName) {
      // find existing role input with same name (case-insensitive)
      const inputs = Array.from(document.querySelectorAll('.role-input'));
      for (const div of inputs) {
        const nameInput = div.querySelector('.role-name');
        const countInput = div.querySelector('.role-count');
        const factionSelect = div.querySelector('.role-faction');
        if (!nameInput) continue;
        if (nameInput.value.trim().toLowerCase() === roleName.toLowerCase()) {
          // increment count
          countInput.value = (parseInt(countInput.value) || 0) + 1;
          updateTotalRoles();
          setTimeout(refresh, 50);
          return;
        }
      }

      // otherwise add new role input prefilled
      const roleDiv = document.createElement('div');
      roleDiv.className = 'role-input';
      roleDiv.innerHTML = `
        <input type="text" placeholder="Role name (e.g., Mafia, Villager)" class="role-name" value="${escapeHtml(roleName)}">
        <select class="role-faction">
          <option value="">(auto)</option>
          <option value="Mafia">Mafia</option>
          <option value="Villagers">Villagers</option>
          <option value="Neutral">Neutral</option>
        </select>
        <input type="number" min="1" value="1" class="role-count">
        <button class="btn remove-btn" onclick="removeRole(this)">Remove</button>
      `;
      rolesContainer.appendChild(roleDiv);
      // set faction select
      const sel = roleDiv.querySelector('.role-faction');
      if (sel) sel.value = factionName || '';
      updateTotalRoles();
      setTimeout(refresh, 50);
    }

    // Load role pool now
    loadRolePool();

    // Poll every second
    refresh();
    setInterval(refresh, 1000);
    
    // --- Host chat logic ---
    let hostChatOpen = false;
    let hostChatEventSource = null;
    const hostChatMessagesEl = () => document.getElementById('hostChatMessages');

    function toggleHostChat() {
      hostChatOpen = !hostChatOpen;
      const panel = document.getElementById('hostChatPanel');
      const btn = document.getElementById('toggleChatBtn');
      if (hostChatOpen) {
        panel.style.display = 'block';
        btn.textContent = 'Close Chat';
        startHostChatStream();
      } else {
        panel.style.display = 'none';
        btn.textContent = 'Lobby Chat';
        stopHostChatStream();
      }
    }

    function startHostChatStream() {
      if (hostChatEventSource) return;
      try {
        hostChatEventSource = new EventSource(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/chat/stream`);
        hostChatEventSource.onmessage = (e) => {
          try {
            const payload = JSON.parse(e.data);
            if (payload.messages) payload.messages.forEach(m => renderHostChatMessage(m));
            if (payload.message) renderHostChatMessage(payload.message);
          } catch (err) { console.warn('Host chat parse error', err); }
        };
        hostChatEventSource.onerror = (err) => {
          console.warn('Host chat SSE error', err);
          // Attempt to reconnect
          stopHostChatStream();
          setTimeout(() => startHostChatStream(), 1200);
        };
      } catch (e) {
        console.warn('Host chat start failed', e);
      }
    }

    // --- Voting SSE for instant host updates ---
    let votingEventSource = null;
    let votingReconnectTimeout = 500;
  // persist last-known voting snapshot on host so dashboard doesn't auto-clear when voting ends
  let persistentHostVotingSnapshot = null;

    function startVotingStream() {
      if (votingEventSource) return;
      try {
        votingEventSource = new EventSource(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/voting/stream`);
        votingEventSource.onmessage = (e) => {
          try {
            const payload = JSON.parse(e.data);
            if (!payload || !payload.voting) return;
            const v = payload.voting;
            // update DOM
            const votingStatusEl = document.getElementById('votingStatus');
            const votingCurrentEl = document.getElementById('votingCurrent');
            const votingTallyEl = document.getElementById('votingTally');
            const votingLogEl = document.getElementById('votingLog');
            // If server signals an explicit reset, clear the host snapshot/UI immediately
            if (v && v.reset) {
              persistentHostVotingSnapshot = null;
              if (votingStatusEl) votingStatusEl.textContent = '—';
              if (votingCurrentEl) votingCurrentEl.textContent = '—';
              if (votingTallyEl) votingTallyEl.textContent = '—';
              if (votingLogEl) votingLogEl.textContent = '—';
            } else if (v) {
              // update persistent snapshot with any voting info we receive
              persistentHostVotingSnapshot = v;

              // Render snapshot: show Active when running, otherwise show Ended but keep tally/log
              if (v.active) {
                if (votingStatusEl) votingStatusEl.textContent = 'Active';
                if (votingCurrentEl) votingCurrentEl.textContent = v.current_voter || '—';
              } else {
                if (votingStatusEl) votingStatusEl.textContent = 'Ended';
                if (votingCurrentEl) votingCurrentEl.textContent = v.current_voter || '—';
              }

              // tally (render from snapshot)
              if (votingTallyEl) {
                const t = (v.tally || {});
                const entries = Object.entries(t).filter(([k, c]) => (c || 0) > 0).sort((a,b)=> b[1]-a[1] || a[0].localeCompare(b[0]));
                if (entries.length) {
                  votingTallyEl.innerHTML = entries.map(([k,c]) => `<div style="display:flex; justify-content:space-between; margin-bottom:0.25rem;"><span>${escapeHtml(k)}</span><strong>${c}</strong></div>`).join('');
                } else {
                  votingTallyEl.textContent = '—';
                }
              }

              // votes log
              if (votingLogEl) {
                const log = (v.votes_log || []);
                if (Array.isArray(log) && log.length) {
                  votingLogEl.innerHTML = log.map(l => `<div style="margin-bottom:0.25rem;">${escapeHtml(l.voter || l.from || '')} → <strong>${escapeHtml(l.choice || l.to || '')}</strong></div>`).join('');
                } else {
                  votingLogEl.textContent = '—';
                }
              }
            }
          } catch (err) {
            console.warn('Voting SSE parse error', err);
          }
        };

        votingEventSource.onerror = (err) => {
          console.warn('Voting SSE error', err);
          // close and attempt reconnect with backoff
          stopVotingStream();
          setTimeout(() => {
            votingReconnectTimeout = Math.min(30000, votingReconnectTimeout * 1.5);
            startVotingStream();
          }, votingReconnectTimeout);
        };
      } catch (e) {
        console.warn('Could not start voting SSE', e);
      }
    }

    function stopVotingStream() {
      if (votingEventSource) {
        try { votingEventSource.close(); } catch (e) {}
        votingEventSource = null;
      }
    }

    // start voting SSE immediately for host page so dashboard updates instantly
    startVotingStream();

    function stopHostChatStream() {
      if (hostChatEventSource) {
        hostChatEventSource.close();
        hostChatEventSource = null;
      }
    }

    function renderHostChatMessage(m) {
      if (!m || !m.sender) return;
      const el = document.createElement('div');
      el.style.padding = '0.35rem 0.5rem';
      el.style.borderBottom = '1px dashed rgba(255,255,255,0.02)';
      // Use the server-provided per-sender color when available so host view matches player colors
      const senderColor = m.color || '#f1f5f9';
      el.innerHTML = `<strong style="color:${senderColor}">${escapeHtml(m.sender)}</strong>: ${escapeHtml(m.text)}`;
      hostChatMessagesEl().appendChild(el);
      hostChatMessagesEl().scrollTop = hostChatMessagesEl().scrollHeight;
    }

    async function sendHostChat() {
      const input = document.getElementById('hostChatInput');
      const text = input.value.trim();
      if (!text) return;
      try {
        const resp = await fetch(`/api/rooms/${encodeURIComponent(ROOM_NAME)}/chat`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: `message=${encodeURIComponent(text)}`
        });
        const d = await resp.json();
        if (d.success) {
          input.value = '';
        } else {
          alert('Chat send failed: ' + (d.error || 'unknown'));
        }
      } catch (e) {
        console.error('Send host chat error', e);
        alert('Error sending chat');
      }
    }

    // Allow pressing Enter in the host chat input to send the message.
    // This mirrors typical chat UX and does not interfere with other handlers.
    try {
      const _hostChatInput = document.getElementById('hostChatInput');
      if (_hostChatInput) {
        _hostChatInput.addEventListener('keydown', (e) => {
          // Only trigger on Enter without modifier keys
          if (e.key === 'Enter' && !e.shiftKey && !e.ctrlKey && !e.metaKey && !e.altKey) {
            e.preventDefault();
            // call the existing sendHostChat (async) and ignore its promise here
            try { sendHostChat(); } catch (err) { console.warn('sendHostChat failed on Enter', err); }
          }
        });
      }
    } catch (e) { /* ignore DOM hookup errors */ }
    
    // Toast utility for host page (mirrors player `showToast`) 
    function showToast(msg, ms = 1200) {
      try {
        const toast = document.getElementById('toast');
        const msgEl = document.getElementById('toastMessage');
        if (!toast || !msgEl) return;
        msgEl.textContent = msg;
        toast.style.display = 'block';
        // fade in
        toast.style.opacity = 0;
        toast.style.transition = 'opacity 160ms ease';
        requestAnimationFrame(() => { toast.style.opacity = 1; });
        setTimeout(() => {
          // fade out
          toast.style.opacity = 0;
          setTimeout(() => { toast.style.display = 'none'; }, 220);
        }, ms);
      } catch (e) { console.warn('Toast failed', e); }
    }

    // Host reveal helpers
    function showHostRevealOverlay({ name, role, cause, logEntries }) {
      try {
        const overlay = document.getElementById('hostRevealOverlay');
        if (!overlay) return;
        document.getElementById('hostRevealName').textContent = name || '';
        document.getElementById('hostRevealRole').textContent = role || '';
        document.getElementById('hostRevealCause').textContent = cause || '';
        const log = document.getElementById('hostEliminationLog');
        if (log) {
          log.innerHTML = '';
          (logEntries||[]).forEach(e => {
            const div = document.createElement('div'); div.style.padding='0.35rem 0'; div.style.borderBottom='1px dashed rgba(255,255,255,0.02)';
            const t = document.createElement('time'); t.textContent = e.time || ''; t.style.color='#94a3b8'; t.style.marginRight='0.5rem';
            const txt = document.createElement('span'); txt.innerHTML = e.text || '';
            div.appendChild(t); div.appendChild(txt); log.appendChild(div);
          });
        }
        overlay.style.display = 'flex';
      } catch (e) { console.warn('showHostRevealOverlay failed', e); }
    }
    function hideHostRevealOverlay() { try { const o = document.getElementById('hostRevealOverlay'); if (o) o.style.display = 'none'; } catch(e) {} }
    function appendHostEliminationLogEntry(entry) {
      try { const log = document.getElementById('hostEliminationLog'); if (!log) return; const div = document.createElement('div'); div.style.padding='0.35rem 0'; div.style.borderBottom='1px dashed rgba(255,255,255,0.02)'; const t = document.createElement('time'); t.textContent = entry.time || new Date().toLocaleTimeString(); t.style.color='#94a3b8'; t.style.marginRight='0.5rem'; const txt = document.createElement('span'); txt.innerHTML = entry.text || ''; div.appendChild(t); div.appendChild(txt); log.appendChild(div); } catch(e) { console.warn('appendHostEliminationLogEntry failed', e); } }
    function copyHostEliminationLog() { try { const log = document.getElementById('hostEliminationLog'); if (!log) return; const text = Array.from(log.querySelectorAll('div')).map(d=>d.textContent.trim()).join('\n'); navigator.clipboard.writeText(text).then(()=> showToast('Log copied')).catch(()=> showToast('Copy failed')); } catch(e) { console.warn('copyHostEliminationLog failed', e); } }
  </script>
  <script>
    async function copyJoinLink() {
      const txt = joinLinkEl.textContent || '';
      const statusEl = document.getElementById('copyStatus');
      try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(txt);
        } else {
          // fallback
          const ta = document.createElement('textarea');
          ta.value = txt;
          document.body.appendChild(ta);
          ta.select();
          document.execCommand('copy');
          ta.remove();
        }
        statusEl.textContent = 'Copied!';
        setTimeout(() => { statusEl.textContent = ''; }, 2000);
      } catch (e) {
        console.error('Copy failed', e);
        statusEl.textContent = 'Copy failed';
        setTimeout(() => { statusEl.textContent = ''; }, 2000);
      }
    }
  </script>
</body>
<script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', function() {
      navigator.serviceWorker.register('/static/sw.js').catch(function(err){ console.warn('SW registration failed:', err); });
    });
  }
  // Initialize host mute toggle (runs after DOM load)
  (function(){
    try {
      const btn = document.getElementById('hostMuteBtn');
      const iconWave = document.getElementById('hostMuteWave');
      if (!btn) return;
      const setMutedState = (muted) => {
        try { btn.setAttribute('aria-pressed', muted ? 'true' : 'false'); } catch(e) {}
        try { btn.title = muted ? 'Unmute site' : 'Mute site'; } catch(e) {}
        if (iconWave) iconWave.style.display = muted ? 'none' : '';
      };
      let initialMuted = false;
      try { initialMuted = localStorage.getItem('siteMuted') === '1'; } catch(e) {}
      setMutedState(initialMuted);
      btn.addEventListener('click', function(){
        try {
          const currently = (localStorage.getItem('siteMuted') === '1');
          const next = !currently;
          localStorage.setItem('siteMuted', next ? '1' : '0');
          setMutedState(next);
        } catch(e) { console.warn('host mute toggle failed', e); }
      });
    } catch(e) { console.warn('host mute init failed', e); }
  })();
</script>
</html>